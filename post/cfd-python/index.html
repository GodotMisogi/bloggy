<!DOCTYPE html> 
<html lang="en">

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script src="//cdn.rawgit.com/paulrosen/abcjs/master/bin/abcjs_basic_3.0-min.js"></script>
<head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# website: http://ogp.me/ns/website#">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="description" content="">
    <meta property="og:title" content="Computational Fluid Dynamics - CFDPython">
    
    <meta property="og:type" content="article">
    <meta property="article:published_time" content="2018-05-05">
    
    <meta property="og:description" content="">
    <meta property="og:url" content="https://godot-bloggy.xyz/post/cfd-python/">
    <meta property="og:site_name" content="Arjit Seth">
    
    <meta property="og:tags" content="Computational Fluid Dynamics">
    
    <meta property="og:tags" content="Programming">
    
    <meta property="og:tags" content="Mathematics">
    
    <meta name="generator" content="Hugo 0.48" />
    <title>Computational Fluid Dynamics - CFDPython</title>
    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://godot-bloggy.xyz/css/style.css">
    <link href="" rel="alternate" type="application/rss+xml" title="Arjit Seth" />
    <link href="https://godot-bloggy.xyz/css/prism.css" rel="stylesheet" />

    
    
    
     <link rel="shortcut icon" href="https://godot-bloggy.xyz//pp.jpg?" type="image/x-icon">
    
    <script src="//cdn.rawgit.com/paulrosen/abcjs/master/bin/abcjs_plugin_3.0-min.js" type="text/javascript"></script>
    <script type="text/javascript">ABCJS.plugin.hide_abc = true;</script>
    
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-89998292-1', 'auto');
    ga('send', 'pageview');
    window.baseURL = "https:\/\/godot-bloggy.xyz\/";
    </script>
  
</head>
<body>
<nav class="navbar navbar-default navbar-fixed-top visible-xs">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			
				<a class="navbar-brand" href="https://godot-bloggy.xyz/">｢ALL FICTION｣</a>
			
		</div>
		<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
			<ul class="nav navbar-nav">
				
				
					<li><a href="https://godot-bloggy.xyz/about">About</a></li>
				
					<li><a href="https://godot-bloggy.xyz/">Blog</a></li>
				
					<li><a href="https://godot-bloggy.xyz/project/">Projects</a></li>
				
			</ul>
		</div>
	</div>
</nav>
<div class="container-fluid">
	<div class="row">
		
<div id="menu" class="hidden-xs col-sm-4 col-md-3">
	<div id="menu-content" class="vertical-align">
		
			<h1 class="text-center"><a href="https://godot-bloggy.xyz/">｢ALL FICTION｣</a></h1>
		
		
		
			<small class="text-center center-block">ARJIT SETH</small>
		
		
		
			<img id="profile-pic" src="https://godot-bloggy.xyz//img/Logo.png" alt="My Picture" class="center-block">
		
		<div id="social" class="text-center">
			<a href="mailto:arjitseth@gmail.com"><i class="fa fa-envelope-o fa-2x"></i></a>
			<a href="https://www.linkedin.com/in/arjit-seth" target="new"><i class="fa fa-linkedin fa-2x"></i></a>
			<a href="https://github.com/GodotMisogi" target="new"><i class="fa fa-github fa-2x"></i></a>
			<a href="https://twitter.com/ArjitSeth" target="new"><i class="fa fa-twitter fa-2x"></i></a>
		</div>
		<div id="links" class="text-center">
			
			
				<a href="https://godot-bloggy.xyz/about">About</a>
			
				<a href="https://godot-bloggy.xyz/">Blog</a>
			
				<a href="https://godot-bloggy.xyz/project/">Projects</a>
			
		</div>
	</div>
</div>
		<div id="content" class="col-xs-12 col-sm-8 col-md-9">
			<div class="row">
				<div id="post" class="col-sm-offset-1 col-sm-10 col-md-10 col-lg-8">

<main>
	<header>
		<h1>Computational Fluid Dynamics - CFDPython</h1>
	</header>

	<article>
		

<p>This &lsquo;notebook&rsquo; consists of my run-through of Prof. Lorena Barba&rsquo;s &ldquo;<a href="http://lorenabarba.com/blog/cfd-python-12-steps-to-navier-stokes/">12 steps to Navier-Stokes</a>&rdquo; course, because I admit I have a problem with fluids. The <a href="https://www.grc.nasa.gov/www/k-12/airplane/nseqs.html">Navier-Stokes</a> equations that will be solved in this notebook are the following in conservative form:</p>

<p>$$ \frac{\partial \rho}{\partial t} + \nabla \cdot \left(\rho V\right) = 0 $$</p>

<p>$$ \frac{\partial (\rho\vec V)}{\partial t} + \nabla \cdot \left(\rho \,\vec V \otimes \vec V + p\hat I \right) = \rho \vec g + \nabla \cdot \hat \tau + \vec f$$</p>

<p>where $\rho$ is the density of the fluid, $\vec V$ denotes the velocity, $p$ denotes the pressure, $\tau$ denotes the stresses, and $f$ denotes body forces. The flows in this tutorial are incompressible cases in which the density is considered constant, so the energy equation is not solved.</p>

<p>The goal of this exercise to solve these equations numerically for some simple cases, starting from the ground-up. It is set in a &ldquo;professor first, student next&rdquo; fashion, with the student developing the stock functions with his/her own ideas. The development is presented in order of relevance to the corresponding steps rather than chronologically. Most of the partial differential equations here are numerically solved using forward difference methods in time and backward difference methods in space.</p>

<p>Programming CFD methods is crucial in understanding how fluid solvers work because it allows one to learn about all possible points of error when running analyses through industrial software/packages, reducing debugging time in the long run.</p>

<h4 id="python-libraries">Python Libraries</h4>

<pre><code class="language-python">import numpy
import sympy
from sympy import init_printing
from sympy.utilities.lambdify import lambdify
import time, sys
from matplotlib import rc, pyplot, cm
from sympy import init_printing
from mpl_toolkits.mplot3d import Axes3D
import timeit
init_printing(use_latex=True)
rc('font',**{'family':'serif'})
rc('text', usetex=True)
</code></pre>

<h3 id="step-1-1d-linear-convection"><strong>Step 1: 1D Linear Convection</strong></h3>

<h4 id="professor">Professor</h4>

<p>Partial differential equation:</p>

<p>$$ \frac{\partial u}{\partial t} + c\frac{\partial u}{\partial x} = 0 $$</p>

<p>Discretised:</p>

<p>$$ \frac{u^{n+1}_i - u^n_i}{\Delta t} + c\frac{u^n_i - u^n_{i-1}}{\Delta x} = 0 $$</p>

<p>Initial condition:</p>

<p>$$ u(x,0)= \begin{cases} 2, &amp; x \in [0.5,1] \\ 1, &amp; \mathrm{everywhere\;else} \end{cases} $$</p>

<pre><code class="language-python">nx = 41
dx = 2.0/(nx-1)
nt = 20
dt = 0.025
c = 1.0

u = numpy.ones(nx)
u[int (.5/dx): int(1/dx + 1)] = 2.0
print(u)

pyplot.figure(1, figsize=(9,4), dpi=300)
pyplot.title('Professor')
pyplot.plot(numpy.linspace(0,2,nx), u)

for n in range(nt):
    un = u.copy()
    for i in range(1,nx):
        u[i] = un[i] - c*dt/dx*(un[i] - un[i-1])

pyplot.figure(2, figsize=(9,4), dpi=300)
pyplot.title('Professor')
pyplot.plot(numpy.linspace(0,2,nx), u)
pyplot.show()
</code></pre>

<pre><code>[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 2. 2. 2. 2. 2. 2. 2. 2. 2. 2. 2. 1. 1. 1.
 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
</code></pre>

<p><img src="../CFDPython_files/1DConvectionInitProf.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/1DConvectionProf.svg" alt="svg" /></p>

<h4 id="student">Student</h4>

<p>No time to lose. (Down with mutability!)</p>

<pre><code class="language-python">def linearConvection(nx):
    dx = 2.0/nx
    nt = 21
    dt = 0.025
    c = 1
    
    x = numpy.linspace(0,2,nx)
    u = numpy.ones((nt,nx))
    u[0][int (.5/dx): int(1/dx +1)] = 2.0

    for n in range(nt-1):
        for i in range(1,nx):
            u[n+1][i] = u[n][i] - c*dt/dx*(u[n][i] - u[n][i-1])
    
    pyplot.figure(1,figsize=(7,3), dpi=300)
    pyplot.title('Student')
    pyplot.plot(x, u[0], label='Initial')
    pyplot.plot(x, u[nt-1], label='Final')
    pyplot.xlabel('Position (m)')
    pyplot.ylabel('Velocity (m/s)')
    pyplot.legend()

linearConvection(40)
</code></pre>

<p><img src="../CFDPython_files/1DConvectionStud.svg" alt="svg" /></p>

<h3 id="step-2-1d-nonlinear-convection"><strong>Step 2: 1D Nonlinear Convection</strong></h3>

<h4 id="professor-1">Professor</h4>

<p>Partial differential equation:</p>

<p>$$ \frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} = 0 $$</p>

<p>Discretised:</p>

<p>$$ \frac{u^{n+1}_i - u^n_i}{\Delta t} + u^n_i\frac{u^n_i - u^n_{i-1}}{\Delta x} = 0 $$</p>

<p>Initial condition:</p>

<p>$$ u(x,0)= \begin{cases} 2, &amp; x \in [0.5,1] \\ 1, &amp; \mathrm{everywhere\;else} \end{cases} $$</p>

<pre><code class="language-python">nx = 41
dx = 2.0/(nx-1)
nt = 20
dt = 0.025

u = numpy.ones(nx)
u[int (.5/dx): int(1/dx + 1)] = 2.0

pyplot.figure(figsize=(9,4), dpi=300)
pyplot.title('Professor')
pyplot.plot(numpy.linspace(0,2,nx), u)

for n in range(nt):
    un = u.copy()
    for i in range(1,nx):
        u[i] = un[i]*(1 - dt/dx*(un[i] - un[i-1]))

pyplot.plot(numpy.linspace(0,2,nx), u)
pyplot.show()
</code></pre>

<p><img src="../CFDPython_files/1DNLConvectionProf.svg" alt="svg" /></p>

<h4 id="student-1">Student</h4>

<pre><code class="language-python">def nonLinearConvection(nx):
    dx = 2.0/nx
    nt = 20
    dt = 0.025
    
    x = numpy.linspace(0,2,nx)
    u = numpy.ones((nt,nx))
    u[0][int (.5/dx): int(1/dx + 1)] = 2.0

    for n in range(nt-1):
        for i in range(1,nx):
            u[n+1][i] = u[n][i]*(1 - dt/dx*(u[n][i] - u[n][i-1]))
            
    return x, u

pos, vel = nonLinearConvection(40)

# Plotting
pyplot.figure(1,figsize=(7,3), dpi=300)
pyplot.title('Student')
pyplot.plot(pos, vel[0], label='Initial')
pyplot.plot(pos, vel[-1], label='Final')
pyplot.xlabel('Position (m)')
pyplot.ylabel('Velocity (m/s)')
pyplot.legend()
pyplot.show()
</code></pre>

<p><img src="../CFDPython_files/1DNLConvectionStud.svg" alt="svg" /></p>

<h3 id="investigation-cfl-condition"><strong>Investigation: CFL Condition</strong></h3>

<h4 id="professor-2">Professor</h4>

<p>Courant number:</p>

<p>$$ \sigma = \frac{u\Delta t}{\Delta x} \leq \sigma_{\max} $$</p>

<pre><code class="language-python">def linearconv(nx):
    dx = 2.0/(nx-1)
    nt = 20
    c = 1.0
    sigma = 0.5
    dt = sigma*dx
    
    u = numpy.ones(nx)
    u[int (.5/dx): int(1/dx + 1)] = 2.0

    pyplot.figure(1, figsize=(9,4), dpi=300)
    pyplot.title('Professor')
    pyplot.plot(numpy.linspace(0,2,nx), u)

    for n in range(nt):
        un = u.copy()
        for i in range(1,nx):
            u[i] = un[i] - c*dt/dx*(un[i] - un[i-1])

    pyplot.plot(numpy.linspace(0,2,nx), u)

linearconv(501)
</code></pre>

<p><img src="../CFDPython_files/1DCFLProf.svg" alt="svg" /></p>

<h4 id="student-2">Student</h4>

<p>This function allows you to input the simulation time and time-step size and provides warnings if the Courant Number is greater than 1 with recommendations.</p>

<pre><code class="language-python">def linearConvectionCFL(mesh_size, time, dt):
    dx = 2.0/mesh_size
    c = 1
    time_steps = int(time/dt)
    sigma_max = dt/dx
    if sigma_max &gt; 1:
        correct_dt = dx
        print(f'Warning: CFL Number greater than 1. Solver will probably produce incorrect results. Maximum time-step should be {correct_dt}')
    
    # Initial condition definition
    x = numpy.linspace(0,2,mesh_size)
    u = numpy.ones((time_steps,mesh_size))
    u[0][int (.5/dx): int(1/dx + 1)] = 2.0

    for n in range(time_steps-1):
        for i in range(1,mesh_size):
            u[n+1][i] = u[n][i] - c*dt/dx*(u[n][i] - u[n][i-1])
            
    return x, u
    
pos, vel = linearConvectionCFL(100, 0.2, 0.021)

# Plotting
pyplot.figure(1,figsize=(7,3), dpi=300)
pyplot.title('Student')
pyplot.plot(pos, vel[0], label='Initial')
pyplot.plot(pos, vel[-1], label='Final')
pyplot.xlabel('Position (m)')
pyplot.ylabel('Velocity (m/s)')
pyplot.legend()
pyplot.show()
</code></pre>

<pre><code>Warning: CFL Number greater than 1. Solver will probably produce incorrect results. Maximum time-step should be 0.02.
</code></pre>

<p><img src="../CFDPython_files/1DCFLStud.svg" alt="svg" /></p>

<h3 id="step-3-diffusion-equation-in-1d"><strong>Step 3: Diffusion Equation in 1D</strong></h3>

<h4 id="professor-3">Professor</h4>

<p>Partial differential equation:</p>

<p>$$ \frac{\partial u}{\partial t} = \nu \frac{\partial^2 u}{\partial x^2} $$</p>

<p>Discretised:</p>

<p>$$ \frac{u^{n+1}_i - u^n_i}{\Delta t} = \nu\frac{u^n_{i+1} - 2u^n_i + u^n_{i-1}}{(\Delta x)^2} $$</p>

<p>Initial condition:</p>

<p>$$ u(x,0)= \begin{cases} 2, &amp; x \in [0.5,1] \\ 1, &amp; \mathrm{everywhere\;else} \end{cases} $$</p>

<pre><code class="language-python">nx = 41
dx = 2.0/(nx-1)
nt = 20
nu = 0.3
sigma = 0.2
dt = sigma*dx**2/nu

u = numpy.ones(nx)
u[int (.5/dx): int(1/dx + 1)] = 2.0
print(u)

pyplot.figure(1, figsize=(9,4), dpi=300)
pyplot.title('Professor')
pyplot.plot(numpy.linspace(0,2,nx), u)

for n in range(nt):
    un = u.copy()
    for i in range(1,nx - 1):
        u[i] = un[i] + nu*dt/dx**2*(un[i+1] - 2*un[i] + un[i-1] )

pyplot.plot(numpy.linspace(0,2,nx), u)
pyplot.show()
</code></pre>

<pre><code>[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 2. 2. 2. 2. 2. 2. 2. 2. 2. 2. 2. 1. 1. 1.
 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
</code></pre>

<p><img src="../CFDPython_files/1DDiffusionProf.svg" alt="svg" /></p>

<h4 id="student-3">Student</h4>

<p><strong>Analytical Solution of the Diffusion Equation using a Fourier Transform:</strong></p>

<p>Take the spatial Fourier transform $\mathcal F_x$ of the equation with an initial value problem:</p>

<p>$$ \frac{\partial u_F(k,t)}{\partial t} + \nu k^2 u_F(k,t) = 0 $$</p>

<p>This ODE is easily solved:</p>

<p>$$ u_F(k,t) = u(k,0)e^{-\nu k^2 t}, \quad u(k,0) = \mathcal F_x[u(x,0)] $$</p>

<p>To find the inverse spatial Fourier transform, we invoke the convolution theorem:</p>

<p>$$ u(x,t) = \mathcal F_x^{-1}\left[u_F(k,t)\right] =  \mathcal F_x^{-1}[u(k,0)] * \mathcal F_x^{-1} \left[e^{-\nu k^2 t}\right] = u(x,0) * \mathcal F_x^{-1} \left[e^{-\nu k^2 t}\right] $$</p>

<p>The second inverse transform is the Fourier transform of a Gaussian, which is nicely found in the following manner. Let $f(k) = e^{-\nu k^2 t}$ (with $\nu$ and $t$ as parameters), now differentiate and take the Fourier transform:</p>

<p>$$ ix \cdot f(x) = -2\nu t \cdot i f&rsquo;(x) $$</p>

<p>$$ \implies f(x) = \frac{1}{\sqrt{4\pi\nu t}}\exp\left(-\frac{x^2}{4\nu t}\right) $$</p>

<p>Using the definition of convolution, the solution can be expressed as:</p>

<p>$$ u(x,t) = \frac{1}{\sqrt{4\pi\nu t}}\int_{-\infty}^{\infty} u(y,0)\exp\left[-\frac{(x-y)^2}{4\nu t}\right] \mathrm dy $$</p>

<p><strong>Note:</strong> This looks strangely similar to a Green&rsquo;s function with the kernel:</p>

<p>$$ G(x,t;y,t) = \frac{1}{\sqrt{4\pi\nu t}}\exp\left[-\frac{(x-y)^2}{4\nu t}\right] $$</p>

<p>Let&rsquo;s apply this solution to the current initial condition:</p>

<p>$$ \begin{align} u(x,t) &amp; =  \frac{1}{\sqrt{4\pi\nu t}}\int_{-\infty}^{0.5}\exp\left[-\frac{(x-y)^2}{4\nu t}\right] \mathrm dy + \frac{2}{\sqrt{4\pi\nu t}}\int_{0.5}^{1}\exp\left[-\frac{(x-y)^2}{4\nu t}\right] \mathrm dy \\<br />
&amp; + \frac{1}{\sqrt{4\pi\nu t}}\int_{1}^{\infty}\exp\left[-\frac{(x-y)^2}{4\nu t}\right] \mathrm dy \end{align}$$</p>

<p>There&rsquo;s no closed-form solution for these integrals. <code>:(</code> But these are expressible using the error function with the substitution:</p>

<p>$$ \frac{x-y}{\sqrt{4\nu t}} = u, \quad \mathrm{erf}(x) =  \frac{2}{\sqrt{\pi}}\int_{0}^{x}e^{-u^2} \mathrm du $$</p>

<p>$$ \implies  u(x,t) =  1 - \frac{1}{2}\mathrm{erf}\left(\frac{x-1}{\sqrt{4\nu t}}\right) + \frac{1}{2}\mathrm{erf}\left(\frac{x-0.5}{\sqrt{4\nu t}}\right)$$</p>

<p>We can now compare our solver&rsquo;s accuracy with this &ldquo;analytical&rdquo; solution!</p>

<p><strong>Note</strong>: This version forces the Courant Number to be 0.2 and calculates the time-step based on the mesh size accordingly for &ldquo;accurate&rdquo; results. It takes user input of simulation time and also runs a calculation using the &ldquo;analytical&rdquo; solution (via <code>sympy</code>) for comparison.</p>

<pre><code class="language-python">## Analytical solution setup using SymPy
x, t, nu = sympy.symbols('x t nu')
u_diffusion = (1 - 0.5*sympy.erf((x-1)/(sympy.sqrt(4*nu*t))) + 
              0.5*sympy.erf((x-0.5)/(sympy.sqrt(4*nu*t))))
u_func_diffusion = sympy.lambdify((t,x,nu), u_diffusion, modules=['numpy', 'sympy'])
</code></pre>

<pre><code class="language-python">def diffusionEquation(mesh_size, time):
    dx = 2.0/mesh_size
    nu = 0.3
    sigma_max = 0.2
    dt = sigma_max*dx**2/nu
    time_steps = int(time/dt)
    
    ## Initial condition definition
    x = numpy.linspace(0,2,mesh_size)
    u = numpy.ones((time_steps,mesh_size))
    u[0][int (.5/dx): int(1/dx + 1)] = 2.0
    u_analytical = numpy.asarray([u_func_diffusion(time_steps*dt, xi, nu) for xi in x])
    
    for n in range(time_steps-1):
        for i in range(1,mesh_size - 1):
            u[n+1][i] = u[n][i] + nu*dt/dx**2*(u[n][i+1] - 2*u[n][i] + u[n][i-1])
    
    return x, u, u_analytical

pos, vel, vel_analytical = diffusionEquation(100, 0.03333)

# Plotting
pyplot.figure(1,figsize=(7,3), dpi=300)
pyplot.title('Student')
pyplot.plot(pos, vel[0], label='Initial')
pyplot.plot(pos, vel[-1], label='Final')
pyplot.plot(pos, vel_analytical, '--', label='Analytical')
pyplot.xlabel('Position (m)')
pyplot.ylabel('Velocity (m/s)')
pyplot.legend()
pyplot.show()
</code></pre>

<p><img src="../CFDPython_files/1DDiffusionStud.svg" alt="svg" /></p>

<h3 id="step-4-burgers-equation"><strong>Step 4: Burgers&rsquo; Equation</strong></h3>

<h3 id="professor-4">Professor</h3>

<p>Partial differential equation:</p>

<p>$$ \frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} = \nu\frac{\partial^2 u}{\partial x^2} $$</p>

<p>Discretised:</p>

<p>$$ \frac{u^{n+1}_i - u^n_i}{\Delta t} + u^n_i\frac{u^n_i - u^n_{i-1}}{\Delta x} = \nu\frac{u^n_{i+1} - 2u^n_i + u^n_{i-1}}{(\Delta x)^2} $$</p>

<p><strong>Student&rsquo;s modification:</strong> The notation has been clarified compared to the original presentation (including a missing condition).</p>

<p>Initial conditions (using the analytical solution):</p>

<p>$$ \phi(x,t)_{t=0} = \exp\left[-\frac{\left(x - 4t - 2\pi\right)^{2}}{4 \nu \left(t + 1\right)}\right] + \exp\left[- \frac{\left(x-4t\right)^{2}}{4 \nu \left(t + 1\right)}\right] $$</p>

<p>$$ u(x,0) = -\frac{2\nu}{\phi}\frac{\partial\phi}{\partial x} + 4 $$</p>

<p>Boundary conditions:</p>

<p>$$ u(0,t) = u(2\pi,t), \quad u&rsquo;(0,t) = u&rsquo;(2\pi, t)$$</p>

<pre><code class="language-python">## Analytical solution setup using SymPy
x, t, nu = sympy.symbols('x t nu')
phi = sympy.exp(-(x-4*t)**2/(4*nu*(t+1))) + sympy.exp(-(x-4*t-2*numpy.pi)**2/(4*nu*(t+1)))
diffphi = sympy.diff(phi, x)
u = -2*nu/phi*diffphi + 4
ufunc = sympy.lambdify((t,x,nu), u)
</code></pre>

<pre><code class="language-python">nx = 81
dx = 2.0*numpy.pi/(nx-1)
nt = 100
nu = 0.07
dt = dx*nu

x = numpy.linspace(0, 2*numpy.pi,nx)
un = numpy.empty(nx)
t = 0

u = numpy.asarray([ufunc(t,x0,nu) for x0 in x])

pyplot.figure(figsize=(9, 4) dpi=300)
pyplot.title('Professor')
pyplot.plot(x, u, marker='o', lw=2)
pyplot.xlim([0, 2 * numpy.pi])
pyplot.ylim([0, 10])

for n in range(nt):
    un = u.copy()
    for i in range(1,nx-1):
        u[i] = un[i]*(1-dt/dx*(un[i] - un[i-1])) + nu*dt/dx**2*(un[i+1] - 2*un[i] + un[i-1])
    u[0] = un[0]*(1-dt/dx*(un[0] - un[-2])) + nu*dt/dx**2*(un[1] - 2*un[0] + un[-2])
    u[-1] = u[0]

u_analytical = numpy.asarray([ufunc(nt*dt, xi, nu) for xi in x])

# Plotting
pyplot.figure(figsize=(9, 4) dpi=300)
pyplot.plot(x, u, marker='o', lw=2, label='Computational')
pyplot.plot(x, u_analytical, label='Analytical')
pyplot.xlim([0, 2 * numpy.pi])
pyplot.ylim([0, 10])
pyplot.legend()
pyplot.show()
</code></pre>

<p><img src="../CFDPython_files/1DBurgerInitProf.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/1DBurgerProf.svg" alt="svg" /></p>

<h4 id="student-4">Student</h4>

<pre><code class="language-python">def burgersEquation(mesh_size, time):
    dx = 2.0*numpy.pi/(mesh_size-1)
    nu = 0.07
    dt = dx*nu
    timesteps = int(time/dt)
    
    x = numpy.linspace(0, 2*numpy.pi, mesh_size)
    u = numpy.empty((timesteps,mesh_size))
    u_analytical = numpy.asarray([ufunc(timesteps*dt, xi, nu) for xi in x])
    
    u[0] = numpy.asarray([ufunc(0,x0,nu) for x0 in x])
    
    for n in range(timesteps-1):
        for i in range(1,mesh_size-1):
            u[n+1][i] = (u[n][i]*(1-dt/dx*(u[n][i] - u[n][i-1])) 
                       + nu*dt/dx**2*(u[n][i+1] - 2*u[n][i] + u[n][i-1])) 
            u[n+1][0] = (u[n][0]*(1-dt/dx*(u[n][0] - u[n][-2])) 
                       + nu*dt/dx**2*(u[n][1] - 2*u[n][0] + u[n][-2]))
            u[n+1][-1] = u[n+1][0]
    
    return x, u, u_analytical

pos, vel, vel_analytical = burgersEquation(101,0.5)

# Plotting
pyplot.figure(1,figsize=(7,4), dpi=300)
pyplot.title('Student')
pyplot.plot(pos, vel[0], marker='o', lw=2, label = 'Initial')
pyplot.plot(pos, vel[-1], marker='o', lw=2, label='Computational Result')
pyplot.plot(pos, vel_analytical, label='Analytical Result')
pyplot.xlabel('Position (m)')
pyplot.ylabel('Velocity (m/s)')
pyplot.xlim([0, 2*numpy.pi])
pyplot.ylim([0, 10])
pyplot.legend()
pyplot.show()
</code></pre>

<p><img src="../CFDPython_files/1DBurgerStud.svg" alt="svg" /></p>

<h3 id="aside-kardar-parisi-zhang-equation"><strong>Aside: Kardar–Parisi–Zhang equation</strong></h3>

<h4 id="student-5">Student</h4>

<p>The KPZ equation is a generalisation of Burgers&rsquo; equation to multiple dimensions. Write Burgers&rsquo; equation in the form:</p>

<p>$$ \frac{\partial u}{\partial t} + \frac{1}{2}\frac{\partial u^2}{\partial x} = \nu\frac{\partial^2 u}{\partial x^2} $$</p>

<p>Let $ u = \psi_x $, then Burgers&rsquo; equation becomes:</p>

<p>$$ \psi_{tx} + \psi_x\psi_{xx} = \nu\psi_{xxx} $$</p>

<p>$$ \partial_x\left(\psi_t + \frac{\psi_x^2}{2} \right) = \nu\partial_x(\psi_{xx}) $$</p>

<p>Integrating with respect to $x$ gives the following equation:</p>

<p>$$ \frac{\partial \psi}{\partial t} + \frac{1}{2}\left(\frac{\partial \psi}{\partial x}\right)^2 = \nu\frac{\partial^2 \psi}{\partial x^2} + \alpha(t) $$</p>

<p>If $\alpha(t) = 0$, we obtain the KPZ equation in one dimension, which seemingly generalises to:</p>

<p>$$ \frac{\partial \psi}{\partial t} + \frac{\lambda}{2}\left(\nabla \psi\right)^2 = \nu\nabla^2 \psi $$</p>

<p>Whatever &ldquo;$(\nabla \psi)^2$&rdquo; means. Let $\lambda = 1$ and take the one-dimensional case, then the equation has an integrating factor (thanks to Vyn from freenode&rsquo;s <code>##math</code>!), which allows it to be written in the form of the 1-D diffusion equation:</p>

<p>$$ \frac{\partial}{\partial t}\left[\exp\left(-\frac{\psi}{2\nu}\right)\right] = \nu\frac{\partial^2}{\partial x^2}\left[\exp\left(-\frac{\psi}{2\nu}\right)\right] $$</p>

<p>TODO: Add solution.</p>

<h3 id="step-5-2d-linear-convection"><strong>Step 5: 2D Linear Convection</strong></h3>

<h4 id="professor-5">Professor</h4>

<p>Partial differential equation:</p>

<p>$$ \frac{\partial u}{\partial t} + c\left(\frac{\partial u}{\partial x} + \frac{\partial u}{\partial y} \right) = 0 $$</p>

<p>Discretised:</p>

<p>$$ \frac{u^{n+1}_{i,j} - u^n_{i,j}}{\Delta t} + c\left(\frac{u^n_{i,j} - u^n_{i-1,j}}{\Delta x} + \frac{u^n_{i,j} - u^n_{i,j-1}}{\Delta y}\right) = 0 $$</p>

<p>Initial condition:</p>

<p>$$ u(x,0)= \begin{cases} 2, &amp; x \in [0.5,1] \times [0.5,1] \\ 1, &amp; \mathrm{everywhere\;else} \end{cases} $$</p>

<p><strong>Student&rsquo;s modification:</strong> This has been modified into a function to take a variable argument, which decides whether to use a &ldquo;fast&rdquo; (which uses array operations with NumPy) or a &ldquo;slow&rdquo; (which uses <code>for</code> loops) implementation. Fast is implemented by default, and the slow variant can be implemented by feeding <code>False</code> into the function. <code>timeit</code> has been imported to clock the processing speeds of each variant.</p>

<pre><code class="language-python">def linearconv2D(fast=True):
    nx = 81
    ny = 81
    dx = 2.0/(nx - 1)
    dy = 2.0/(ny - 1)
    c = 1
    sigma = 0.2
    nt = 100
    dt = sigma*dx

    x = numpy.linspace(0, 2, nx)
    y = numpy.linspace(0, 2, ny)
    
    u = numpy.ones((ny,nx))
    un = numpy.ones((ny,nx))
    u[int(0.5/dy):int(1.0/dy + 1),int(.5/dx):int(1.0/dx + 1)] = 2 
    
    fig = pyplot.figure(figsize=(9,7) dpi=300)
    ax = fig.gca(projection='3d')
    X, Y = numpy.meshgrid(x,y)
    surf = ax.plot_surface(X, Y, u[:], cmap=cm.viridis)
    pyplot.title('Professor')
    
    if fast:
        tick = timeit.default_timer()
        for n in range(nt + 1):
            un = u.copy()
            u[1:,1:] = u[1:,1:] - c*dt*((u[1:,1:] - u[:-1,1:])/dx + (u[1:,1:] - u[1:,:-1])/dy)
            u[0,:] = 1
            u[-1,:] = 1
            u[:,0] = 1
            u[:,-1] = 1
        tock = timeit.default_timer()
        print('Array operations took %s seconds' %(tock - tick))
    else:
        tick = timeit.default_timer()
        for n in range(nt + 1):
            un = u.copy()
            row, col = u.shape
            for j in range(1, row):
                for i in range(1, col):
                    u[j,i] = un[j,i] - c*dt*((un[j,i] - un[j,i-1])/dx + (un[j,i] - un[j-1,i])/dy)
                    u[0,:] = 1
                    u[-1,:] = 1
                    u[:,0] = 1
                    u[:,-1] = 1
        tock = timeit.default_timer()
        print('For loops took %s seconds' %(tock - tick))
        
    fig = pyplot.figure(figsize=(9, 7), dpi=300)
    ax = fig.gca(projection='3d')
    surf2 = ax.plot_surface(X, Y, u[:], cmap=cm.viridis)
    
linearconv2D()
linearconv2D(False)
</code></pre>

<pre><code>Array operations took 0.009733499959111214 seconds
For loops took 4.577128199976869 seconds
</code></pre>

<p><img src="../CFDPython_files/2DLinearConvectionInitProf.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DLinearConvectionProf.svg" alt="svg" /></p>

<h4 id="student-6">Student</h4>

<p>This function takes the mesh size in each direction as separate inputs and also the required simulation time. It minimises the time-step based on the smaller grid distance between <code>x</code> and <code>y</code> for accuracy (at the cost of speed!).</p>

<pre><code class="language-python">def linearConvection2D(mesh_size_x, mesh_size_y, time):
    dx = 2/(mesh_size_x - 1)
    dy = 2/(mesh_size_y - 1)
    c = 1
    sigma = 0.2
    dt = sigma*min(dx,dy)
    timesteps = int(time/dt)
    
    x = numpy.linspace(0,2, mesh_size_x)
    y = numpy.linspace(0,2, mesh_size_y)
    
    u = numpy.ones((timesteps, mesh_size_x, mesh_size_y))
    u[0][int(0.5/dy):int(1.0/dy + 1),int(.5/dx):int(1.0/dx + 1)] = 2
    
    for n in range(timesteps-1):
        u[n+1][1:,1:] = (u[n][1:,1:] - c*dt*((u[n][1:,1:] - u[n][:-1,1:])/dx 
                       + (u[n][1:,1:] - u[n][1:,:-1])/dy))
        u[n+1][0,:] = 1
        u[n+1][-1,:] = 1
        u[n+1][:,0] = 1
        u[n+1][:,-1] = 1
        
    return x, y, u
    
pos_x, pos_y, vel = linearConvection2D(201, 201, 2.5/5.0)

# Plotting
fig = pyplot.figure(1, figsize=(9,7), dpi=300)
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(pos_x, pos_y)
surf = ax.plot_surface(X, Y, vel[0], cmap=cm.viridis)
pyplot.title('Student')

fig2 = pyplot.figure(2, figsize=(9,7), dpi=300)
ax = fig2.gca(projection='3d')
X, Y = numpy.meshgrid(pos_x, pos_y)
surf2 = ax.plot_surface(X, Y, vel[-1], cmap=cm.viridis)
pyplot.show()
</code></pre>

<p><img src="../CFDPython_files/2DLinearConvectionInitStud.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DLinearConvectionStud.svg" alt="svg" /></p>

<h3 id="step-6-2d-convection"><strong>Step 6: 2D Convection</strong></h3>

<h4 id="professor-6">Professor</h4>

<p>Coupled partial differential equations:</p>

<p>$$ \frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} + v\frac{\partial u}{\partial y}  = 0 $$</p>

<p>$$ \frac{\partial v}{\partial t} + u\frac{\partial v}{\partial x} + v\frac{\partial v}{\partial y}  = 0 $$</p>

<p>(Student: I think there&rsquo;s a factor $c$ missing in them.) Discretised:</p>

<p>$$ \frac{u^{n+1}_{i,j} - u^n_{i,j}}{\Delta t} + u^n_{i,j}\left(\frac{u^n_{i,j} - u^n_{i-1,j}}{\Delta x}\right) + v^n_{i,j}\left(\frac{u^n_{i,j} - u^n_{i,j-1}}{\Delta y}\right) = 0 $$</p>

<p>$$ \frac{v^{n+1}_{i,j} - v^n_{i,j}}{\Delta t} + u^n_{i,j}\left(\frac{v^n_{i,j} - v^n_{i-1,j}}{\Delta x}\right) + v^n_{i,j}\left(\frac{v^n_{i,j} - v^n_{i,j-1}}{\Delta y}\right) = 0 $$</p>

<p>Initial conditions:</p>

<p>$$ u, v = \begin{cases} 2, &amp; x,y \in [0.5,1] \times [0.5,1] \\ 1, &amp; \mathrm{everywhere\;else} \end{cases}$$</p>

<p>Boundary conditions:</p>

<p>$$ u = 1, v = 1 \;\mathrm{for} \begin{cases} x = 0,2 \\ y = 0,2 \end{cases} $$</p>

<pre><code class="language-python">nx = 101
ny = 101
nt = 80
c = 1
dx = 2.0/(nx-1)
dy = 2.0/(ny-1)
sigma = 0.2
dt = sigma*dx

x = numpy.linspace(0, 2, nx)
y = numpy.linspace(0, 2, ny)

u = numpy.ones((ny, nx))
v = numpy.ones((ny, nx))
un = numpy.ones((ny, nx))
vn = numpy.ones((ny, nx))

u[int(.5 / dy):int(1 / dy + 1),int(.5 / dx):int(1 / dx + 1)] = 2  
v[int(.5 / dy):int(1 / dy + 1),int(.5 / dx):int(1 / dx + 1)] = 2  

fig = pyplot.figure(figsize=(9,7), dpi=300)
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(x, y)

ax.plot_surface(X, Y, u, cmap=cm.viridis, rstride=2, cstride=2)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$')
pyplot.title('Professor')

for n in range(nt + 1):
    un = u.copy()
    vn = v.copy()
    u[1:, 1:] = (un[1:, 1:] - un[1:, 1:] * c * dt / dx
               * (un[1:, 1:] - un[1:, :-1]) - vn[1:, 1:] * c * dt / dy 
               * (un[1:, 1:] - un[:-1, 1:]))
    v[1:, 1:] = (vn[1:, 1:] - un[1:, 1:] * c * dt / dx
               * (vn[1:, 1:] - vn[1:, :-1]) - vn[1:, 1:] * c * dt / dy 
               * (vn[1:, 1:] - vn[:-1, 1:])_
    u[0, :] = 1
    u[-1, :] = 1
    u[:, 0] = 1
    u[:, -1] = 1
    
    v[0, :] = 1
    v[-1, :] = 1
    v[:, 0] = 1
    v[:, -1] = 1

fig = pyplot.figure(figsize=(9, 7), dpi=300)
ax = fig.gca(projection='3d')
ax.plot_surface(X, Y, u, cmap=cm.viridis, rstride=2, cstride=2)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$')
pyplot.show()
</code></pre>

<p><img src="../CFDPython_files/2DNLConvectionInitProf.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DNLConvectionProf.svg" alt="svg" /></p>

<h4 id="student-7">Student</h4>

<p>These PDEs can be written concisely in tensor notation using Einstein&rsquo;s summation convention:</p>

<p>$$ \partial_t V^{\alpha} + cV^{\mu}\partial_{\mu}V^{\alpha} = 0 $$</p>

<p>However, there doesn&rsquo;t seem to be a neat way to write the discretisation in index notation. The computation has been made slightly more efficient by computing <code>c*dt/dx</code> and <code>c*dt/dy</code> outside the <code>for</code> loop, since those values are fixed, and hence do not need to be computed repeatedly. The same applies to the boundary conditions.</p>

<pre><code class="language-python">def convection2D(mesh_size_x, mesh_size_y, time):
    c = 1.0
    dx = 2.0/(mesh_size_x-1)
    dy = 2.0/(mesh_size_y-1)
    sigma = 0.2
    dt = sigma*min(dx,dy)
    timesteps = int(time/dt)
    
    x = numpy.linspace(0, 2.0, mesh_size_x)
    y = numpy.linspace(0, 2.0, mesh_size_y)

    u = numpy.ones((timesteps, mesh_size_x, mesh_size_y))
    v = numpy.ones((timesteps, mesh_size_x, mesh_size_y))
    
    # Initial conditions
    u[0, int(.5/dx):int(1/dx + 1),int(.5/dy):int(1/dy + 1)] = 2.0
    v[0, int(.5/dx):int(1/dx + 1),int(.5/dy):int(1/dy + 1)] = 2.0
    
    # Boundary conditions
    u[1:, 0,:] = 1.0
    u[1:, -1,:] = 1.0
    u[1:, :,0] = 1.0
    u[1:, :,-1] = 1.0
    v[1:, 0,:] = 1.0
    v[1:, -1,:] = 1.0
    v[1:, :,0] = 1.0
    v[1:, :,-1] = 1.0
    
    ctx = c*dt/dx
    cty = c*dt/dy
    for n in range(timesteps-1):
        u[n+1, 1:, 1:] = (u[n, 1:,1:] - ctx*(u[n, 1:,1:]*(u[n, 1:,1:] - u[n,:-1,1:])) 
                        - cty*(v[n, 1:,1:]*(u[n, 1:,1:] - u[n, 1:,:-1])))
        v[n+1, 1:, 1:] = (v[n, 1:,1:] - ctx*(u[n, 1:,1:]*(v[n, 1:,1:] - v[n,:-1,1:])) 
                        - cty*(v[n, 1:,1:]*(v[n, 1:,1:] - v[n, 1:,:-1])))

    return x, y, u, v
    
pos_x, pos_y, vel_x, vel_y = convection2D(201, 201, 0.32)

# Plotting
fig = pyplot.figure(1, figsize=(9, 7), dpi=300)
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(pos_x, pos_y)
surf = ax.plot_surface(X, Y, vel_x[0], cmap=cm.viridis, rstride=2, cstride=2)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$')
pyplot.title('Student')

fig2 = pyplot.figure(2, figsize=(9, 7), dpi=300)
ax = fig2.gca(projection='3d')
X, Y = numpy.meshgrid(pos_x, pos_y)
surf2 = ax.plot_surface(X, Y, vel_y[-1], cmap=cm.viridis, rstride=2, cstride=2)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$')
pyplot.show()
</code></pre>

<p><img src="../CFDPython_files/2DNLConvectionInitStud.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DNLConvectionStud.svg" alt="svg" /></p>

<h3 id="step-7-2d-diffusion"><strong>Step 7: 2D Diffusion</strong></h3>

<h4 id="professor-7">Professor</h4>

<p>Partial differential equation:</p>

<p>$$ \frac{\partial u}{\partial t} = \nu\left(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}\right) $$</p>

<p>Discretised:</p>

<p>$$ \frac{u^{n+1}_i - u^n_i}{\Delta t} = \nu\left[\frac{u^n_{i+1} - 2u^n_i + u^n_{i-1}}{(\Delta x)^2} + \frac{u^n_{i+1} - 2u^n_i + u^n_{i-1}}{(\Delta y)^2}\right] $$</p>

<p>Initial conditions:</p>

<p>$$ u, v = \begin{cases} 2, &amp; x,y \in [0.5,1] \times [0.5,1] \\ 1, &amp; \mathrm{everywhere\;else} \end{cases}$$</p>

<p>Boundary conditions:</p>

<p>$$ u = 1, v = 1 \;\mathrm{for} \begin{cases} x = 0,2 \\ y = 0,2 \end{cases} $$</p>

<pre><code class="language-python">nx = 31
ny = 31
nu = .05
dx = 2 / (nx - 1)
dy = 2 / (ny - 1)
sigma = .25
dt = sigma*dx*dy/nu

x = numpy.linspace(0,2,nx)
y = numpy.linspace(0,2,ny)

u = numpy.ones((ny,nx))
un = numpy.ones((ny,nx))

u[int(.5/dy):int(1/dy+1),int(.5/dx):int(1/dx+1)] = 2

fig = pyplot.figure(figsize=(9,7), dpi=300)
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(x, y)
surf = ax.plot_surface(X, Y, u, rstride=1, cstride=1, cmap=cm.viridis,
        linewidth=0, antialiased=False)
ax.set_xlim(0, 2)
ax.set_ylim(0, 2)
ax.set_zlim(1, 2.5)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$')
pyplot.title('Professor')

def diffuse(nt):
    u[int(.5 / dy):int(1 / dy + 1),int(.5 / dx):int(1 / dx + 1)] = 2  # Student: Why is this repeated?

    for n in range(nt+1):
        un = u.copy()
        u[1:-1, 1:-1] = (un[1:-1, 1:-1] 
                       + nu * dt / dx**2 * (un[1:-1, 2:] - 2 * un[1:-1, 1:-1] + un[1:-1, 0:-2]) 
                       + nu * dt / dy**2 * (un[2:,1: -1] - 2 * un[1:-1, 1:-1] + un[0:-2, 1:-1]))
        u[0,:] = 1
        u[-1,:] = 1
        u[:,0] = 1
        u[:,-1] = 1
    
    fig2 = pyplot.figure(figsize=(9,7), dpi=300)
    ax = fig2.gca(projection='3d')
    surf2 = ax.plot_surface(X, Y, u[:], rstride=1, cstride=1, cmap=cm.viridis,
        linewidth=0, antialiased=True)
    ax.set_zlim(1, 2.5)
    ax.set_xlabel('$x$')
    ax.set_ylabel('$y$')
    
diffuse(50)
</code></pre>

<p><img src="../CFDPython_files/2DDiffusionInitProf.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DDiffusionProf.svg" alt="svg" /></p>

<h4 id="student-8">Student</h4>

<p>The current setup is also symmetric, so computing the second component of the velocity is redundant, since $u = v$ and they&rsquo;re decoupled. I also prefer the rainbow colour map.</p>

<pre><code class="language-python">def diffusion2D(mesh_size_x, mesh_size_y, time):
    nu = 0.05
    dx = 2.0/(mesh_size_x-1)
    dy = 2.0/(mesh_size_y-1)
    sigma = 0.25
    dt = sigma*dx*dy/nu
    timesteps = int(time/dt)
    
    x = numpy.linspace(0, 2, mesh_size_x)
    y = numpy.linspace(0, 2, mesh_size_y)

    u = numpy.ones((timesteps, mesh_size_x, mesh_size_y))
    
    # Initial conditions
    u[0, int(.5/dx):int(1/dx + 1),int(.5/dy):int(1/dy + 1)] = 2
    
    # Boundary conditions
    u[1:, 0,:] = 1
    u[1:, -1,:] = 1
    u[1:, :,0] = 1
    u[1:, :,-1] = 1
    
    lambda_x = nu*dt/dx**2
    lambda_y = nu*dt/dy**2
    for n in range(timesteps-1):
        u[n+1, 1:-1,1:-1] = (u[n, 1:-1, 1:-1]
                           + lambda_x*(u[n, 2:, 1:-1] - 2*u[n, 1:-1,1:-1] + u[n, :-2, 1:-1]) 
                           + lambda_y*(u[n, 1:-1, 2:] - 2*u[n, 1:-1, 1:-1] + u[n, 1:-1, :-2]))
        
    return x, y, u
    
pos_x, pos_y, vel_x = diffusion2D(31, 31, 0.5)

# Plotting
fig = pyplot.figure(1, figsize=(9, 7), dpi=300)
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(pos_x, pos_y)
surf = ax.plot_surface(X, Y, numpy.transpose(vel_x[0]), rstride=1, cstride=1, cmap=cm.rainbow, linewidth=0, antialiased=False)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$')
pyplot.title('Student')

fig2 = pyplot.figure(2, figsize=(9, 7), dpi=300)
ax = fig2.gca(projection='3d')
X, Y = numpy.meshgrid(pos_x, pos_y)
surf2 = ax.plot_surface(X, Y, numpy.transpose(vel_x[-1]), rstride=1, cstride=1, cmap=cm.rainbow, linewidth=0, antialiased=True)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$')
pyplot.show()
</code></pre>

<p><img src="../CFDPython_files/2DDiffusionInitStud.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DDiffusionStud.svg" alt="svg" /></p>

<h3 id="step-8-burgers-equation-in-2d"><strong>Step 8: Burgers&rsquo; Equation in 2D</strong></h3>

<h4 id="professor-8">Professor</h4>

<p>Partial differential equations:</p>

<p>$$ \frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} + v\frac{\partial u}{\partial y} = \nu\left(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}\right) $$</p>

<p>$$ \frac{\partial v}{\partial t} + u\frac{\partial v}{\partial x} + v\frac{\partial v}{\partial y} = \nu\left(\frac{\partial^2 v}{\partial x^2} + \frac{\partial^2 v}{\partial y^2}\right) $$</p>

<p>Discretised:</p>

<p>\begin{split}<br />
&amp; \frac{u_{i,j}^{n+1} - u_{i,j}^n}{\Delta t} + u_{i,j}^n \frac{u_{i,j}^n-u_{i-1,j}^n}{\Delta x} + v_{i,j}^n \frac{u_{i,j}^n - u_{i,j-1}^n}{\Delta y} = \\<br />
&amp; \qquad \nu \left( \frac{u_{i+1,j}^n - 2u_{i,j}^n+u_{i-1,j}^n}{\Delta x^2} + \frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{\Delta y^2} \right)<br />
\end{split}</p>

<p>\begin{split}<br />
&amp; \frac{v_{i,j}^{n+1} - v_{i,j}^n}{\Delta t} + u_{i,j}^n \frac{v_{i,j}^n-v_{i-1,j}^n}{\Delta x} + v_{i,j}^n \frac{v_{i,j}^n - v_{i,j-1}^n}{\Delta y} = \\<br />
&amp; \qquad \nu \left( \frac{v_{i+1,j}^n - 2v_{i,j}^n+v_{i-1,j}^n}{\Delta x^2} + \frac{v_{i,j+1}^n - 2v_{i,j}^n + v_{i,j-1}^n}{\Delta y^2} \right)<br />
\end{split}</p>

<pre><code class="language-python">nx = 41
ny = 41
nt = 120
c = 1
dx = 2 / (nx - 1)
dy = 2 / (ny - 1)
sigma = .0009
nu = 0.01
dt = sigma * dx * dy / nu

x = numpy.linspace(0, 2, nx)
y = numpy.linspace(0, 2, ny)

u = numpy.ones((ny, nx))
v = numpy.ones((ny, nx))
un = numpy.ones((ny, nx)) 
vn = numpy.ones((ny, nx))
comb = numpy.ones((ny, nx))

u[int(.5 / dy):int(1 / dy + 1),int(.5 / dx):int(1 / dx + 1)] = 2 
v[int(.5 / dy):int(1 / dy + 1),int(.5 / dx):int(1 / dx + 1)] = 2 

fig = pyplot.figure(figsize=(9, 7), dpi=300)
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(x, y)
ax.plot_surface(X, Y, u[:], cmap=cm.viridis, rstride=1, cstride=1)
ax.plot_surface(X, Y, v[:], cmap=cm.viridis, rstride=1, cstride=1)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$')
pyplot.title('Professor')

for n in range(nt + 1): ##loop across number of time steps
    un = u.copy()
    vn = v.copy()

    u[1:-1, 1:-1] = (un[1:-1, 1:-1] -
                     dt / dx * un[1:-1, 1:-1] * 
                     (un[1:-1, 1:-1] - un[1:-1, 0:-2]) - 
                     dt / dy * vn[1:-1, 1:-1] * 
                     (un[1:-1, 1:-1] - un[0:-2, 1:-1]) + 
                     nu * dt / dx**2 * 
                     (un[1:-1,2:] - 2 * un[1:-1, 1:-1] + un[1:-1, 0:-2]) + 
                     nu * dt / dy**2 * 
                     (un[2:, 1:-1] - 2 * un[1:-1, 1:-1] + un[0:-2, 1:-1]))
    
    v[1:-1, 1:-1] = (vn[1:-1, 1:-1] - 
                     dt / dx * un[1:-1, 1:-1] *
                     (vn[1:-1, 1:-1] - vn[1:-1, 0:-2]) -
                     dt / dy * vn[1:-1, 1:-1] * 
                    (vn[1:-1, 1:-1] - vn[0:-2, 1:-1]) + 
                     nu * dt / dx**2 * 
                     (vn[1:-1, 2:] - 2 * vn[1:-1, 1:-1] + vn[1:-1, 0:-2]) +
                     nu * dt / dy**2 *
                     (vn[2:, 1:-1] - 2 * vn[1:-1, 1:-1] + vn[0:-2, 1:-1]))
     
    u[0, :] = 1
    u[-1, :] = 1
    u[:, 0] = 1
    u[:, -1] = 1
    
    v[0, :] = 1
    v[-1, :] = 1
    v[:, 0] = 1
    v[:, -1] = 1
    
fig = pyplot.figure(figsize=(9, 7), dpi=300)
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(x, y)
ax.plot_surface(X, Y, u, cmap=cm.viridis, rstride=1, cstride=1)
ax.plot_surface(X, Y, v, cmap=cm.viridis, rstride=1, cstride=1)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$')
</code></pre>

<p><img src="../CFDPython_files/2DBurgerInitProf.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DBurgerProf.svg" alt="svg" /></p>

<h4 id="student-9">Student</h4>

<p>Contour plots look better than surface plots.</p>

<pre><code class="language-python">def burgers2D(mesh_size_x, mesh_size_y, time):
    nu = 0.01
    dx = 2.0/(mesh_size_x-1)
    dy = 2.0/(mesh_size_y-1)
    sigma = 0.0009
    dt = sigma*dx*dy/nu
    timesteps = int(time/dt)
    
    x = numpy.linspace(0, 2, mesh_size_x)
    y = numpy.linspace(0, 2, mesh_size_y)

    u = numpy.ones((timesteps, mesh_size_x, mesh_size_y))
    v = numpy.ones((timesteps, mesh_size_x, mesh_size_y))
    
    # Initial conditions
    u[0, int(.5/dx):int(1/dx + 1), int(.5/dy):int(1/dy + 1)] = 2
    v[0, int(.5/dx):int(1/dx + 1), int(.5/dy):int(1/dy + 1)] = 2
    
    # Boundary conditions
    u[1:, 0,:] = 1
    u[1:, -1,:] = 1
    u[1:, :,0] = 1
    u[1:, :,-1] = 1
    v[1:, 0,:] = 1
    v[1:, -1,:] = 1
    v[1:, :,0] = 1
    v[1:, :,-1] = 1

    r_x = dt/dx
    r_y = dt/dy
    lambda_x = nu*dt/dx**2
    lambda_y = nu*dt/dy**2
    for n in range(timesteps-1):
        u[n+1, 1:-1, 1:-1] = (u[n, 1:-1,1:-1]
                            - r_x*u[n, 1:-1, 1:-1]*(u[n, 1:-1, 1:-1] - u[n, :-2, 1:-1]) 
                            - r_y*v[n, 1:-1, 1:-1]*(u[n, 1:-1, 1:-1] - u[n, 1:-1, :-2])
                            + lambda_x*(u[n, 2:, 1:-1] - 2*u[n, 1:-1, 1:-1] + u[n, :-2, 1:-1]) 
                            + lambda_y*(u[n, 1:-1, 2:] - 2*u[n, 1:-1, 1:-1] + u[n, 1:-1, :-2]))
        
        v[n+1, 1:-1, 1:-1] = (v[n, 1:-1,1:-1]
                            - r_x*u[n, 1:-1, 1:-1]*(v[n, 1:-1, 1:-1] - v[n, :-2, 1:-1])
                            - r_y*v[n, 1:-1, 1:-1]*(v[n, 1:-1, 1:-1] - v[n, 1:-1, :-2]) 
                            + lambda_x*(v[n, 1:-1, 2:] - 2*v[n, 1:-1, 1:-1] + v[n, 1:-1, :-2]) 
                            + lambda_y*(v[n, 2:, 1:-1] - 2*v[n, 1:-1, 1:-1] + v[n, :-2, 1:-1]))
        
    return x, y, u, v
    
pos_x, pos_y, vel_x, vel_y = burgers2D(101, 101, 0.2)

X, Y = numpy.meshgrid(pos_x, pos_y)

# Plotting
fig = pyplot.figure(1, figsize=(7, 5), dpi=300)
pyplot.contour(X, Y, numpy.transpose(vel_x[0]), 100)
pyplot.pcolormesh(X, Y, numpy.transpose(vel_x[0]), cmap=cm.jet)
pyplot.xlabel('$x$')
pyplot.ylabel('$y$')
cbar = pyplot.colorbar()
cbar.set_label(r'$u\_{\mathrm{init}}$')
pyplot.title('Student')

fig2 = pyplot.figure(2, figsize=(7, 5), dpi=300)
pyplot.contour(X, Y, numpy.transpose(vel_x[-1]), 100)
pyplot.pcolormesh(X, Y, numpy.transpose(vel_x[-1]), cmap=cm.jet)
pyplot.xlabel('$x$')
pyplot.ylabel('$y$')
cbar = pyplot.colorbar()
cbar.set_label(r'$u\_{\mathrm{final}}$')
pyplot.show()
</code></pre>

<p><img src="../CFDPython_files/2DBurgerInitStud.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DBurgerStud.svg" alt="svg" /></p>

<h3 id="step-9-2d-laplace-equation"><strong>Step 9: 2D Laplace Equation</strong></h3>

<h4 id="professor-9">Professor</h4>

<p>Partial differential equation:</p>

<p>$$ \frac{\partial^2 p}{\partial x^2} + \frac{\partial^2 p}{\partial y^2} = 0 $$</p>

<p>Discretised:</p>

<p>$$ \frac{p^n_{i+1,j} - 2p^n_{i,j} + p^n_{i-1,j}}{\Delta x^2} + \frac{p^n_{i,j+1} - 2p^n_{i,j} + p^n_{i,j-1}}{\Delta y^2} = 0 $$</p>

<p>Gist: There is no time-dependence, so the $n$ represents the iteration number from some initial guess.</p>

<p>The implementation is left as an exercise for the student, with boundary conditions:</p>

<p>$$ p(0,y) = 0, \; p(2,y) = y, \; \frac{\partial p}{\partial y}\bigg|_{(x,0),\,(x,1)} = 0$$</p>

<p>Analytical solution for this case:</p>

<p>$$ p(x,y) = \frac{x}{4} - 4\sum_{n=0}^{\infty} \frac{\sin{[(2n+1)\pi x]}\cos{[(2n+1)\pi y]}}{[(2n+1)\pi]^2\sinh{[(2n+1)\pi x]}} $$</p>

<h4 id="student-10">Student</h4>

<p>The point of this step is to use functions, which is what&rsquo;s been done so far. The plotter could be written as a function. The solver functions can also be generalised to accept the user&rsquo;s desired domain. Apparently NumPy&rsquo;s <code>meshgrid</code> transposes the domain grid.</p>

<p>The derivative boundary condition needs to be discretised appropriately to avoid unknowns:</p>

<p>$$ p_{i,0} = p_{i,1}, \; p_{i,n-1} = p_{i,n}$$</p>

<pre><code class="language-python">def plotContour2D(pos_x, pos_y, var, index, figsize=(7,5), dpi=300, title=None, zlabel=None):
    fig = pyplot.figure(figsize=figsize, dpi=300)
    X, Y = numpy.meshgrid(pos_x, pos_y)
    pyplot.contour(X, Y, numpy.transpose(var[index]), 100)
    pyplot.pcolormesh(X, Y, numpy.transpose(var[index]), cmap=cm.jet)
    pyplot.xlabel('$x$')
    pyplot.ylabel('$y$')
    cbar = pyplot.colorbar()
    if title is not None:
        pyplot.title(title)
    if zlabel is not None:
        cbar.set_label(zlabel)
    pyplot.tight_layout()
    return fig

def plotSurface2D(pos_x, pos_y, var, index, figsize=(10,7), dpi=300, title=None, zlabel=None):
    fig = pyplot.figure(figsize=figsize, dpi=300)
    ax = fig.gca(projection='3d')
    X, Y = numpy.meshgrid(pos_x, pos_y)
    surf = ax.plot_surface(X, Y, numpy.transpose(var[index]), rstride=1, cstride=1, cmap=cm.rainbow, linewidth=0, antialiased=False)
    ax.set_xlabel('$x$')
    ax.set_ylabel('$y$')
    cbar = fig.colorbar(surf, shrink=0.7)
    if title is not None:
        pyplot.title(title)
    if zlabel is not None:
        cbar.set_label(zlabel)
    pyplot.tight_layout()
    return fig

def laplace2D(mesh_size_x, mesh_size_y, xrange, yrange, residual, max_iter = 500):
    dx = abs(xrange[1] - xrange[0])/(mesh_size_x - 1)
    dy = abs(yrange[1] - yrange[0])/(mesh_size_y - 1)
    
    x = numpy.linspace(xrange[0], xrange[1], mesh_size_x)
    y = numpy.linspace(yrange[0], yrange[1], mesh_size_y)

    p = numpy.ones((max_iter, mesh_size_x, mesh_size_y))
    
    # Initial guess
    p[0, :, :] = 0
    p[0, 0, :] = 0
    p[0, -1, :] = numpy.linspace(yrange[0], yrange[1], mesh_size_y)
    p[0, :, 0] = p[0, :, 1]
    p[0, :, -1] = p[0, :, -2]
    
    res = 1.0
    n = 0
    while (n &lt; max_iter - 1):
        p[n+1, 1:-1, 1:-1] = ((dy**2*(p[n, 2:, 1:-1] + p[n, :-2, 1:-1]) 
                            + dx**2*(p[n, 1:-1, 2:] + p[n, 1:-1, :-2]))/(2.0*(dx**2 + dy**2)))

        p[n+1, 0, :] = 0
        p[n+1, -1, :] = numpy.linspace(yrange[0], yrange[1], mesh_size_y)
        p[n+1, :, 0] = p[n, :, 1]
        p[n+1, :, -1] = p[n, :, -2]
        
        residual = numpy.sum(numpy.abs(p[n+1]) - numpy.abs(p[n]))/numpy.sum(numpy.abs(p[n]))
        n = n + 1
        
    return x, y, p
                    
pos_x, pos_y, pressure = laplace2D(101, 51, (0,2), (0,2), 1e-3, 2000)
                    
contour = plotContour2D(pos_x, pos_y, pressure, -1, title='Student', zlabel='$p$')
surf = plotSurface2D(pos_x, pos_y, pressure, -1, zlabel='$p$')
</code></pre>

<p><img src="../CFDPython_files/2DLaplaceContStud.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DLaplaceSurfStud.svg" alt="svg" /></p>

<h3 id="step-10-2d-poisson-equation"><strong>Step 10: 2D Poisson Equation</strong></h3>

<h4 id="professor-10">Professor</h4>

<p>Partial differential equation:</p>

<p>$$ \frac{\partial^2 p}{\partial x^2} + \frac{\partial^2 p}{\partial y^2} = b(x,y) $$</p>

<p>Discretised:</p>

<p>$$ \frac{p^n_{i+1,j} - 2p^n_{i,j} + p^n_{i-1,j}}{\Delta x^2} + \frac{p^n_{i,j+1} - 2p^n_{i,j} + p^n_{i,j-1}}{\Delta y^2} = b^n_{i,j} $$</p>

<p>Gist: There is no time-dependence, so the $n$ represents the iteration number from some initial guess.</p>

<p>The initial guess is $p = 0$ everywhere with the boundary conditions:</p>

<p>$$ p(x,0) = p(x,1) = p(0,y) = p(2,y) = 0 $$</p>

<p>Source terms:</p>

<p>$$ b(x,y) = 0, \; b(x_{max}/4, y_{max}/4) = 100, \; b(3x_{max}/4, 3y_{max}/4) = -100 $$</p>

<pre><code class="language-python"># Parameters
nx = 50
ny = 50
nt  = 100
xmin = 0
xmax = 2
ymin = 0
ymax = 1

dx = (xmax - xmin) / (nx - 1)
dy = (ymax - ymin) / (ny - 1)

# Initialization
p  = numpy.zeros((ny, nx))
pd = numpy.zeros((ny, nx))
b  = numpy.zeros((ny, nx))
x  = numpy.linspace(xmin, xmax, nx)
y  = numpy.linspace(xmin, xmax, ny)

# Source
b[int(ny / 4), int(nx / 4)]  = 100
b[int(3 * ny / 4), int(3 * nx / 4)] = -100

for it in range(nt):

    pd = p.copy()

    p[1:-1,1:-1] = (((pd[1:-1, 2:] + pd[1:-1, :-2]) * dy**2 +
                    (pd[2:, 1:-1] + pd[:-2, 1:-1]) * dx**2 -
                    b[1:-1, 1:-1] * dx**2 * dy**2) / 
                    (2 * (dx**2 + dy**2)))

    p[0, :] = 0
    p[ny-1, :] = 0
    p[:, 0] = 0
    p[:, nx-1] = 0
    
def plot2D(x, y, p):
    fig = pyplot.figure(figsize=(11, 7), dpi=300)
    ax = fig.gca(projection='3d')
    X, Y = numpy.meshgrid(x, y)
    surf = ax.plot_surface(X, Y, p[:], rstride=1, cstride=1, cmap=cm.viridis,
            linewidth=0, antialiased=False)
    ax.view_init(30, 225)
    ax.set_xlabel('$x$')
    ax.set_ylabel('$y$')
    
    # Student: Why not return the figure?
    return fig
    
surf = plot2D(x, y, p)
pyplot.title('Professor')
</code></pre>

<p><img src="../CFDPython_files/2DPoissonProf.svg" alt="svg" /></p>

<h4 id="student-11">Student</h4>

<pre><code class="language-python">def poisson2D(mesh_size_x, mesh_size_y, xrange, yrange, residual, max_iter = 500):
    dx = abs(xrange[1] - xrange[0])/(mesh_size_x - 1)
    dy = abs(yrange[1] - yrange[0])/(mesh_size_y - 1)
    
    x = numpy.linspace(xrange[0], xrange[1], mesh_size_x)
    y = numpy.linspace(yrange[0], yrange[1], mesh_size_y)

    p = numpy.ones((max_iter, mesh_size_x, mesh_size_y))
    b = numpy.zeros((mesh_size_x, mesh_size_y))
    
    # Initial guess
    p[0, :, :] = 0
    p[:, 0, :] = 0
    p[:, -1, :] = 0
    p[:, :, 0] = 0
    p[:, :, -1] = 0
    
    # Source term
    b[int(mesh_size_x/4), int(mesh_size_y/4)] = 100
    b[int(3*mesh_size_x/4), int(3*mesh_size_y/4)] = -100
    
    res = 1.0
    n = 0
    while n &lt; max_iter - 1:
        p[n+1, 1:-1, 1:-1] = ((dy**2*(p[n, 2:, 1:-1] + p[n, :-2, 1:-1])
                            + dx**2*(p[n, 1:-1, 2:] + p[n, 1:-1, :-2]) 
                            - b[1:-1, 1:-1]*dx**2*dy**2)/(2.0*(dx**2 + dy**2)))

        residual = numpy.sum(numpy.abs(p[n+1]) - numpy.abs(p[n]))/numpy.sum(numpy.abs(p[n]))
        n = n + 1
        
    return x, y, p
                    
pos_x, pos_y, pressure = poisson2D(101, 51, (0,2), (0,2), 1e-3, 2000)
                    
contour = plotContour2D(pos_x, pos_y, pressure, -1, title='Student', zlabel='$p$')
surf = plotSurface2D(pos_x, pos_y, pressure, -1, zlabel='$p$')
</code></pre>

<p><img src="../CFDPython_files/2DPoissonContStud.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DPoissonSurfStud.svg" alt="svg" /></p>

<h3 id="step-11-cavity-flow-with-navier-stokes"><strong>Step 11: Cavity Flow with Navier-Stokes</strong></h3>

<h4 id="professor-11">Professor</h4>

<p>Partial differential equations:</p>

<p>$$ \frac{\partial u}{\partial t}+u\frac{\partial u}{\partial x}+v\frac{\partial u}{\partial y} = -\frac{1}{\rho}\frac{\partial p}{\partial x}+\nu \left(\frac{\partial^2 u}{\partial x^2}+\frac{\partial^2 u}{\partial y^2} \right) $$</p>

<p>$$ \frac{\partial v}{\partial t}+u\frac{\partial v}{\partial x}+v\frac{\partial v}{\partial y} = -\frac{1}{\rho}\frac{\partial p}{\partial y}+\nu\left(\frac{\partial^2 v}{\partial x^2}+\frac{\partial^2 v}{\partial y^2}\right) $$</p>

<p>$$ \frac{\partial^2 p}{\partial x^2}+\frac{\partial^2 p}{\partial y^2} = -\rho\left(\frac{\partial u}{\partial x}\frac{\partial u}{\partial x}+2\frac{\partial u}{\partial y}\frac{\partial v}{\partial x}+\frac{\partial v}{\partial y}\frac{\partial v}{\partial y} \right) $$</p>

<p>Discretised:</p>

<p>\begin{split}<br />
&amp; \frac{u_{i,j}^{n+1}-u_{i,j}^{n}}{\Delta t}+u_{i,j}^{n}\frac{u_{i,j}^{n}-u_{i-1,j}^{n}}{\Delta x}+v_{i,j}^{n}\frac{u_{i,j}^{n}-u_{i,j-1}^{n}}{\Delta y} = \\<br />
&amp; \qquad -\frac{1}{\rho}\frac{p_{i+1,j}^{n}-p_{i-1,j}^{n}}{2\Delta x}+\nu\left(\frac{u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}}{\Delta x^2}+\frac{u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}}{\Delta y^2}\right)<br />
\end{split}</p>

<p>\begin{split}<br />
&amp; \frac{v_{i,j}^{n+1}-v_{i,j}^{n}}{\Delta t}+u_{i,j}^{n}\frac{v_{i,j}^{n}-v_{i-1,j}^{n}}{\Delta x}+v_{i,j}^{n}\frac{v_{i,j}^{n}-v_{i,j-1}^{n}}{\Delta y} = \\<br />
&amp; \qquad -\frac{1}{\rho}\frac{p_{i,j+1}^{n}-p_{i,j-1}^{n}}{2\Delta y}<br />
+\nu\left(\frac{v_{i+1,j}^{n}-2v_{i,j}^{n}+v_{i-1,j}^{n}}{\Delta x^2}+\frac{v_{i,j+1}^{n}-2v_{i,j}^{n}+v_{i,j-1}^{n}}{\Delta y^2}\right)<br />
\end{split}</p>

<p>\begin{split}<br />
&amp; \frac{p_{i+1,j}^{n}-2p_{i,j}^{n}+p_{i-1,j}^{n}}{\Delta x^2} + \frac{p_{i,j+1}^{n}-2p_{i,j}^{n}+p_{i,j-1}^{n}}{\Delta y^2} = \\<br />
&amp; \qquad \rho\left[\frac{1}{\Delta t}\left(\frac{u_{i+1,j}-u_{i-1,j}}{2\Delta x}+\frac{v_{i,j+1}-v_{i,j-1}}{2\Delta y}\right) \right] \\<br />
&amp; \qquad -\rho\left[\left(\frac{u_{i+1,j}-u_{i-1,j}}{2\Delta x}\right)^2 + 2\frac{u_{i,j+1}-u_{i,j-1}}{2\Delta y}\frac{v_{i+1,j}-v_{i-1,j}}{2\Delta x} + \left(\frac{v_{i,j+1}-v_{i,j-1}}{2\Delta y}\right)^2\right]<br />
\end{split}</p>

<p>The initial condition is zero everywhere for all variables. Boundary conditions:</p>

<p>$$ u(x_{bound},y_{bound}) = 0, \; u(x,2) = 2,\; \frac{\partial p}{\partial y}\bigg|_{y = 0} = 0,\; p(x,2) = 0,\; \frac{\partial p}{\partial x}\bigg|_{x = 0, 2} = 0 $$</p>

<pre><code class="language-python">nx = 41
ny = 41
nt = 500
nit = 50
c = 1
dx = 2 / (nx - 1)
dy = 2 / (ny - 1)
x = numpy.linspace(0, 2, nx)
y = numpy.linspace(0, 2, ny)
X, Y = numpy.meshgrid(x, y)

rho = 1
nu = .1
dt = .001

u = numpy.zeros((ny, nx))
v = numpy.zeros((ny, nx))
p = numpy.zeros((ny, nx)) 
b = numpy.zeros((ny, nx))

# To avoid typos
def build_up_b(b, rho, dt, u, v, dx, dy):
    
    b[1:-1, 1:-1] = (rho * (1 / dt * 
                    ((u[1:-1, 2:] - u[1:-1, 0:-2]) / 
                     (2 * dx) + (v[2:, 1:-1] - v[0:-2, 1:-1]) / (2 * dy)) -
                    ((u[1:-1, 2:] - u[1:-1, 0:-2]) / (2 * dx))**2 -
                      2 * ((u[2:, 1:-1] - u[0:-2, 1:-1]) / (2 * dy) *
                           (v[1:-1, 2:] - v[1:-1, 0:-2]) / (2 * dx))-
                          ((v[2:, 1:-1] - v[0:-2, 1:-1]) / (2 * dy))**2))

    return b

def pressure_poisson(p, dx, dy, b):
    pn = numpy.empty_like(p)
    pn = p.copy()
    
    for q in range(nit):
        pn = p.copy()
        p[1:-1, 1:-1] = (((pn[1:-1, 2:] + pn[1:-1, 0:-2]) * dy**2 + 
                          (pn[2:, 1:-1] + pn[0:-2, 1:-1]) * dx**2) /
                          (2 * (dx**2 + dy**2)) -
                          dx**2 * dy**2 / (2 * (dx**2 + dy**2)) * 
                          b[1:-1,1:-1])

        p[:, -1] = p[:, -2] # dp/dx = 0 at x = 2
        p[0, :] = p[1, :]   # dp/dy = 0 at y = 0
        p[:, 0] = p[:, 1]   # dp/dx = 0 at x = 0
        p[-1, :] = 0        # p = 0 at y = 2
        
    return p

def cavity_flow(nt, u, v, dt, dx, dy, p, rho, nu):
    un = numpy.empty_like(u)
    vn = numpy.empty_like(v)
    b = numpy.zeros((ny, nx))
    
    for n in range(nt):
        un = u.copy()
        vn = v.copy()
        
        b = build_up_b(b, rho, dt, u, v, dx, dy)
        p = pressure_poisson(p, dx, dy, b)
        
        u[1:-1, 1:-1] = (un[1:-1, 1:-1]-
                         un[1:-1, 1:-1] * dt / dx *
                        (un[1:-1, 1:-1] - un[1:-1, 0:-2]) -
                         vn[1:-1, 1:-1] * dt / dy *
                        (un[1:-1, 1:-1] - un[0:-2, 1:-1]) -
                         dt / (2 * rho * dx) * (p[1:-1, 2:] - p[1:-1, 0:-2]) +
                         nu * (dt / dx**2 *
                        (un[1:-1, 2:] - 2 * un[1:-1, 1:-1] + un[1:-1, 0:-2]) +
                         dt / dy**2 *
                        (un[2:, 1:-1] - 2 * un[1:-1, 1:-1] + un[0:-2, 1:-1])))

        v[1:-1,1:-1] = (vn[1:-1, 1:-1] -
                        un[1:-1, 1:-1] * dt / dx *
                       (vn[1:-1, 1:-1] - vn[1:-1, 0:-2]) -
                        vn[1:-1, 1:-1] * dt / dy *
                       (vn[1:-1, 1:-1] - vn[0:-2, 1:-1]) -
                        dt / (2 * rho * dy) * (p[2:, 1:-1] - p[0:-2, 1:-1]) +
                        nu * (dt / dx**2 *
                       (vn[1:-1, 2:] - 2 * vn[1:-1, 1:-1] + vn[1:-1, 0:-2]) +
                        dt / dy**2 *
                       (vn[2:, 1:-1] - 2 * vn[1:-1, 1:-1] + vn[0:-2, 1:-1])))

        u[0, :]  = 0
        u[:, 0]  = 0
        u[:, -1] = 0
        u[-1, :] = 1    # set velocity on cavity lid equal to 1
        v[0, :]  = 0
        v[-1, :] = 0
        v[:, 0]  = 0
        v[:, -1] = 0
        
    return u, v, p

u = numpy.zeros((ny, nx))
v = numpy.zeros((ny, nx))
p = numpy.zeros((ny, nx))
b = numpy.zeros((ny, nx))
nt = 100
u, v, p = cavity_flow(nt, u, v, dt, dx, dy, p, rho, nu)

fig = pyplot.figure(figsize=(7,5), dpi=300)
# plotting the pressure field as a contour
pyplot.contourf(X, Y, p, alpha=0.5, cmap=cm.viridis)  
pyplot.colorbar()
# plotting the pressure field outlines
pyplot.contour(X, Y, p, cmap=cm.viridis)  
# plotting velocity field
pyplot.quiver(X[::2, ::2], Y[::2, ::2], u[::2, ::2], v[::2, ::2]) 
pyplot.xlabel('X')
pyplot.ylabel('Y');
pyplot.title('Professor')

fig = pyplot.figure(figsize=(7,5), dpi=300)
pyplot.contourf(X, Y, p, alpha=0.5, cmap=cm.viridis)
pyplot.colorbar()
pyplot.contour(X, Y, p, cmap=cm.viridis)
pyplot.streamplot(X, Y, u, v)
pyplot.xlabel('X')
pyplot.ylabel('Y');
</code></pre>

<p><img src="../CFDPython_files/2DCavityProf.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DCavityStreamProf.svg" alt="svg" /></p>

<h4 id="student-12">Student</h4>

<p>No noticeable improvements to be made, except the usual boundary condition computation out of the loop and recording time-evolution.</p>

<pre><code class="language-python">def pressureSource(b, rho, u, v, dx, dy, dt):
    
    b[1:-1, 1:-1] = (rho*(1/(2.0*dt)*((u[2:, 1:-1] - u[:-2, 1:-1])/dx 
                    + (v[1:-1, 2:] - v[1:-1, :-2])/dy)
                    - ((u[2:, 1:-1] - u[:-2, 1:-1])/(2.0*dx))**2
                    - (u[1:-1, 2:] - u[1:-1, :-2])*(v[2:, 1:-1] - v[:-2, 1:-1])/(2.0*dx*dy) 
                    - ((v[1:-1, 2:] - v[1:-1, :-2])/(2.0*dy))**2))
    
    return b
                  
def pressurePoisson(p, b, dx, dy, sub_iterations=50):
    pn = numpy.empty_like(p)
    pn = p.copy()
    for n in range(sub_iterations):
        pn = p.copy()
        p[1:-1, 1:-1] = ((pn[2:, 1:-1] + pn[:-2, 1:-1])*dy**2
                        + (pn[1:-1, 2:] + pn[1:-1, :-2])*dx**2
                        - dx**2*dy**2*b[1:-1, 1:-1])/(2.0*(dx**2 + dy**2)) 
        
    p[:, -1] = 0.
    p[:, 0] = p[:, 1]
    p[0, :] = p[1, :]
    p[-1, :] = p[-2, :]
    
    return p
                
def cavityFlow2D(bounds, mesh_size_x, mesh_size_y, timesteps, dt, u_init, v_init, p_init, rho, nu, sub_iterations=50):
    dx = abs(bounds[0][1] - bounds[0][0])/mesh_size_x 
    dy = abs(bounds[1][1] - bounds[1][0])/mesh_size_y
    u = numpy.zeros((timesteps, mesh_size_x, mesh_size_y))
    v = numpy.zeros((timesteps, mesh_size_x, mesh_size_y))
    p = numpy.zeros((timesteps, mesh_size_x, mesh_size_y))
    b = numpy.zeros((mesh_size_x, mesh_size_y))
    
    u[0, :, :] = u_init
    v[0, :, :] = v_init
    p[0, :, :] = p_init
    
    u[1:, :, -1] = 1.
    
    l_x = dt/dx
    l_y = dt/dy
    n_x = nu*dt/dx**2
    n_y = nu*dt/dy**2
    for n in range(1,timesteps):
        
        b = pressureSource(b, rho, u[n-1], v[n-1], dx, dy, dt)
        p[n] = pressurePoisson(p[n-1], b, dx, dy, sub_iterations)
        
        u[n, 1:-1, 1:-1] = (u[n-1, 1:-1, 1:-1]*(1 - l_x*(u[n-1, 1:-1, 1:-1] - u[n-1, :-2, 1:-1]))
                          - v[n-1, 1:-1, 1:-1]*l_y*(u[n-1, 1:-1, 1:-1] - u[n-1, 1:-1, :-2])
                          - l_x/(2.0*rho)*(p[n, 2:, 1:-1] - p[n, :-2, 1:-1])
                          + n_x*(u[n-1, 2:, 1:-1] - 2.0*u[n-1, 1:-1, 1:-1] + u[n-1, :-2, 1:-1])
                          + n_y*(u[n-1, 1:-1, 2:] - 2.0*u[n-1, 1:-1, 1:-1] + u[n-1, 1:-1, :-2]))
        v[n, 1:-1, 1:-1] = (v[n-1, 1:-1, 1:-1]*(1 - l_y*(v[n-1, 1:-1, 1:-1] - v[n-1, 1:-1, :-2]))
                          - u[n-1, 1:-1, 1:-1]*l_x*(v[n-1, 1:-1, 1:-1] - v[n-1, :-2, 1:-1])
                          - l_x/(2.0*rho)*(p[n, 1:-1, 2:] - p[n, 1:-1, :-2])
                          + n_x*(v[n-1, 2:, 1:-1] - 2.0*v[n-1, 1:-1, 1:-1] + v[n-1, :-2, 1:-1])
                          + n_y*(v[n-1, 1:-1, 2:] - 2.0*v[n-1, 1:-1, 1:-1] + v[n-1, 1:-1, :-2]))
        
    return u, v, p

mesh_size_x = 100
mesh_size_y = 120
rho = 1
nu = .1
timesteps = 500
dt = .001
sub_iterations = 100
x_domain = (0,4)
y_domain = (0,2)
x = numpy.linspace(x_domain[0], x_domain[1], mesh_size_x)
y = numpy.linspace(y_domain[0], y_domain[1], mesh_size_y)
X, Y = numpy.meshgrid(x, y)
u_i = numpy.zeros((mesh_size_x, mesh_size_y))
v_i = numpy.zeros((mesh_size_x, mesh_size_y))
p_i = numpy.zeros((mesh_size_x, mesh_size_y))
u, v, p = cavityFlow2D([x_domain, y_domain], mesh_size_x, mesh_size_y, timesteps, dt, u_i, v_i, p_i, rho, nu, sub_iterations)

fig = pyplot.figure(figsize=(7,5), dpi=300)
pyplot.contourf(X, Y, numpy.transpose(p[-1]), alpha=0.5, cmap=cm.rainbow)  
pyplot.colorbar(label='$p$')
pyplot.contour(X, Y, numpy.transpose(p[-1]), cmap=cm.rainbow)  
pyplot.quiver(X[::2, ::2], Y[::2, ::2], numpy.transpose(u[-1, ::2, ::2]), numpy.transpose(v[-1, ::2, ::2])) 
pyplot.xlabel('$x$')
pyplot.ylabel('$y$')
pyplot.title('Student')

fig = pyplot.figure(figsize=(7,5), dpi=300)
pyplot.contourf(X, Y, numpy.transpose(p[-1]), alpha=0.5, cmap=cm.rainbow)
pyplot.colorbar(label='$p$')
pyplot.contour(X, Y, numpy.transpose(p[-1]), cmap=cm.rainbow)
pyplot.streamplot(X, Y, numpy.transpose(u[-1]), numpy.transpose(v[-1]))
pyplot.xlabel('$x$')
pyplot.ylabel('$y$')
pyplot.show()
</code></pre>

<p><img src="../CFDPython_files/2DCavityStud.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DCavityStreamStud.svg" alt="svg" /></p>

<h3 id="step-12-channel-flow-with-navier-stokes">Step 12: Channel Flow with Navier-Stokes</h3>

<h4 id="professor-12">Professor</h4>

<p>Partial differential equations:</p>

<p>$$ \frac{\partial u}{\partial t}+u\frac{\partial u}{\partial x}+v\frac{\partial u}{\partial y}=-\frac{1}{\rho}\frac{\partial p}{\partial x}+\nu\left(\frac{\partial^2 u}{\partial x^2}+\frac{\partial^2 u}{\partial y^2}\right)+F $$</p>

<p>$$ \frac{\partial v}{\partial t}+u\frac{\partial v}{\partial x}+v\frac{\partial v}{\partial y}=-\frac{1}{\rho}\frac{\partial p}{\partial y}+\nu\left(\frac{\partial^2 v}{\partial x^2}+\frac{\partial^2 v}{\partial y^2}\right) $$</p>

<p>$$ \frac{\partial^2 p}{\partial x^2}+\frac{\partial^2 p}{\partial y^2}=-\rho\left(\frac{\partial u}{\partial x}\frac{\partial u}{\partial x}+2\frac{\partial u}{\partial y}\frac{\partial v}{\partial x}+\frac{\partial v}{\partial y}\frac{\partial v}{\partial y}\right) $$</p>

<p>Discretised:</p>

<p>\begin{split}<br />
&amp; \frac{u_{i,j}^{n+1}-u_{i,j}^{n}}{\Delta t}+u_{i,j}^{n}\frac{u_{i,j}^{n}-u_{i-1,j}^{n}}{\Delta x}+v_{i,j}^{n}\frac{u_{i,j}^{n}-u_{i,j-1}^{n}}{\Delta y} = \\<br />
&amp; \qquad -\frac{1}{\rho}\frac{p_{i+1,j}^{n}-p_{i-1,j}^{n}}{2\Delta x} \\<br />
&amp; \qquad +\nu\left(\frac{u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}}{\Delta x^2}+\frac{u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}}{\Delta y^2}\right)+F_{i,j}<br />
\end{split}</p>

<p>\begin{split}<br />
&amp; \frac{v_{i,j}^{n+1}-v_{i,j}^{n}}{\Delta t}+u_{i,j}^{n}\frac{v_{i,j}^{n}-v_{i-1,j}^{n}}{\Delta x}+v_{i,j}^{n}\frac{v_{i,j}^{n}-v_{i,j-1}^{n}}{\Delta y} = \\<br />
&amp; \qquad -\frac{1}{\rho}\frac{p_{i,j+1}^{n}-p_{i,j-1}^{n}}{2\Delta y} \\<br />
&amp; \qquad +\nu\left(\frac{v_{i+1,j}^{n}-2v_{i,j}^{n}+v_{i-1,j}^{n}}{\Delta x^2}+\frac{v_{i,j+1}^{n}-2v_{i,j}^{n}+v_{i,j-1}^{n}}{\Delta y^2}\right)<br />
\end{split}</p>

<p>\begin{split}<br />
&amp; \frac{p_{i+1,j}^{n}-2p_{i,j}^{n}+p_{i-1,j}^{n}}{\Delta x^2} + \frac{p_{i,j+1}^{n}-2p_{i,j}^{n}+p_{i,j-1}^{n}}{\Delta y^2} = \\<br />
&amp; \qquad \rho\left[\frac{1}{\Delta t}\left(\frac{u_{i+1,j}-u_{i-1,j}}{2\Delta x}+\frac{v_{i,j+1}-v_{i,j-1}}{2\Delta y}\right) \right] \\<br />
&amp; \qquad -\rho\left[\left(\frac{u_{i+1,j}-u_{i-1,j}}{2\Delta x}\right)^2 + 2\frac{u_{i,j+1}-u_{i,j-1}}{2\Delta y}\frac{v_{i+1,j}-v_{i-1,j}}{2\Delta x} + \left(\frac{v_{i,j+1}-v_{i,j-1}}{2\Delta y}\right)^2\right]<br />
\end{split}</p>

<p>The initial condition is zero everywhere for all variables. Boundary conditions:</p>

<p>$u,\, v$ and $p$ are periodic on $x = 0,2$</p>

<p>$$ u(x,0) = u(x,2) = v(x,0) = v(x,2) = 0, \; \frac{\partial p}{\partial y}\bigg|_{y=0,2} = 0, \; F(x,y) = 1,\, \forall (x,y) \in [0,2]\times[0,2]$$</p>

<pre><code class="language-python">def build_up_b(rho, dt, dx, dy, u, v):
    b = numpy.zeros_like(u)
    b[1:-1, 1:-1] = (rho * (1 / dt * ((u[1:-1, 2:] - u[1:-1, 0:-2]) / (2 * dx) +
                                      (v[2:, 1:-1] - v[0:-2, 1:-1]) / (2 * dy)) -
                            ((u[1:-1, 2:] - u[1:-1, 0:-2]) / (2 * dx))**2 -
                            2 * ((u[2:, 1:-1] - u[0:-2, 1:-1]) / (2 * dy) *
                                 (v[1:-1, 2:] - v[1:-1, 0:-2]) / (2 * dx))-
                            ((v[2:, 1:-1] - v[0:-2, 1:-1]) / (2 * dy))**2))
    
    # Periodic BC Pressure @ x = 2
    b[1:-1, -1] = (rho * (1 / dt * ((u[1:-1, 0] - u[1:-1,-2]) / (2 * dx) +
                                    (v[2:, -1] - v[0:-2, -1]) / (2 * dy)) -
                          ((u[1:-1, 0] - u[1:-1, -2]) / (2 * dx))**2 -
                          2 * ((u[2:, -1] - u[0:-2, -1]) / (2 * dy) *
                               (v[1:-1, 0] - v[1:-1, -2]) / (2 * dx)) -
                          ((v[2:, -1] - v[0:-2, -1]) / (2 * dy))**2))

    # Periodic BC Pressure @ x = 0
    b[1:-1, 0] = (rho * (1 / dt * ((u[1:-1, 1] - u[1:-1, -1]) / (2 * dx) +
                                   (v[2:, 0] - v[0:-2, 0]) / (2 * dy)) -
                         ((u[1:-1, 1] - u[1:-1, -1]) / (2 * dx))**2 -
                         2 * ((u[2:, 0] - u[0:-2, 0]) / (2 * dy) *
                              (v[1:-1, 1] - v[1:-1, -1]) / (2 * dx))-
                         ((v[2:, 0] - v[0:-2, 0]) / (2 * dy))**2))
    
    return b

def pressure_poisson_periodic(p, dx, dy):
    pn = numpy.empty_like(p)
    
    for q in range(nit):
        pn = p.copy()
        p[1:-1, 1:-1] = (((pn[1:-1, 2:] + pn[1:-1, 0:-2]) * dy**2 +
                          (pn[2:, 1:-1] + pn[0:-2, 1:-1]) * dx**2) /
                         (2 * (dx**2 + dy**2)) -
                         dx**2 * dy**2 / (2 * (dx**2 + dy**2)) * b[1:-1, 1:-1])

        # Periodic BC Pressure @ x = 2
        p[1:-1, -1] = (((pn[1:-1, 0] + pn[1:-1, -2])* dy**2 +
                        (pn[2:, -1] + pn[0:-2, -1]) * dx**2) /
                       (2 * (dx**2 + dy**2)) -
                       dx**2 * dy**2 / (2 * (dx**2 + dy**2)) * b[1:-1, -1])

        # Periodic BC Pressure @ x = 0
        p[1:-1, 0] = (((pn[1:-1, 1] + pn[1:-1, -1])* dy**2 +
                       (pn[2:, 0] + pn[0:-2, 0]) * dx**2) /
                      (2 * (dx**2 + dy**2)) -
                      dx**2 * dy**2 / (2 * (dx**2 + dy**2)) * b[1:-1, 0])
        
        # Wall boundary conditions, pressure
        p[-1, :] =p[-2, :]  # dp/dy = 0 at y = 2
        p[0, :] = p[1, :]  # dp/dy = 0 at y = 0
    
    return p

##variable declarations
nx = 41
ny = 41
nt = 10
nit = 50 
c = 1
dx = 2 / (nx - 1)
dy = 2 / (ny - 1)
x = numpy.linspace(0, 2, nx)
y = numpy.linspace(0, 2, ny)
X, Y = numpy.meshgrid(x, y)

##physical variables
rho = 1
nu = .1
F = 1
dt = .01

#initial conditions
u = numpy.zeros((ny, nx))
un = numpy.zeros((ny, nx))

v = numpy.zeros((ny, nx))
vn = numpy.zeros((ny, nx))

p = numpy.ones((ny, nx))
pn = numpy.ones((ny, nx))

b = numpy.zeros((ny, nx))

udiff = 1
stepcount = 0

while udiff &gt; .001:
    un = u.copy()
    vn = v.copy()

    b = build_up_b(rho, dt, dx, dy, u, v)
    p = pressure_poisson_periodic(p, dx, dy)

    u[1:-1, 1:-1] = (un[1:-1, 1:-1] -
                     un[1:-1, 1:-1] * dt / dx * 
                    (un[1:-1, 1:-1] - un[1:-1, 0:-2]) -
                     vn[1:-1, 1:-1] * dt / dy * 
                    (un[1:-1, 1:-1] - un[0:-2, 1:-1]) -
                     dt / (2 * rho * dx) * 
                    (p[1:-1, 2:] - p[1:-1, 0:-2]) +
                     nu * (dt / dx**2 * 
                    (un[1:-1, 2:] - 2 * un[1:-1, 1:-1] + un[1:-1, 0:-2]) +
                     dt / dy**2 * 
                    (un[2:, 1:-1] - 2 * un[1:-1, 1:-1] + un[0:-2, 1:-1])) + 
                     F * dt)

    v[1:-1, 1:-1] = (vn[1:-1, 1:-1] -
                     un[1:-1, 1:-1] * dt / dx * 
                    (vn[1:-1, 1:-1] - vn[1:-1, 0:-2]) -
                     vn[1:-1, 1:-1] * dt / dy * 
                    (vn[1:-1, 1:-1] - vn[0:-2, 1:-1]) -
                     dt / (2 * rho * dy) * 
                    (p[2:, 1:-1] - p[0:-2, 1:-1]) +
                     nu * (dt / dx**2 *
                    (vn[1:-1, 2:] - 2 * vn[1:-1, 1:-1] + vn[1:-1, 0:-2]) +
                     dt / dy**2 * 
                    (vn[2:, 1:-1] - 2 * vn[1:-1, 1:-1] + vn[0:-2, 1:-1])))

    # Periodic BC u @ x = 2     
    u[1:-1, -1] = (un[1:-1, -1] - un[1:-1, -1] * dt / dx * 
                  (un[1:-1, -1] - un[1:-1, -2]) -
                   vn[1:-1, -1] * dt / dy * 
                  (un[1:-1, -1] - un[0:-2, -1]) -
                   dt / (2 * rho * dx) *
                  (p[1:-1, 0] - p[1:-1, -2]) + 
                   nu * (dt / dx**2 * 
                  (un[1:-1, 0] - 2 * un[1:-1,-1] + un[1:-1, -2]) +
                   dt / dy**2 * 
                  (un[2:, -1] - 2 * un[1:-1, -1] + un[0:-2, -1])) + F * dt)

    # Periodic BC u @ x = 0
    u[1:-1, 0] = (un[1:-1, 0] - un[1:-1, 0] * dt / dx *
                 (un[1:-1, 0] - un[1:-1, -1]) -
                  vn[1:-1, 0] * dt / dy * 
                 (un[1:-1, 0] - un[0:-2, 0]) - 
                  dt / (2 * rho * dx) * 
                 (p[1:-1, 1] - p[1:-1, -1]) + 
                  nu * (dt / dx**2 * 
                 (un[1:-1, 1] - 2 * un[1:-1, 0] + un[1:-1, -1]) +
                  dt / dy**2 *
                 (un[2:, 0] - 2 * un[1:-1, 0] + un[0:-2, 0])) + F * dt)

    # Periodic BC v @ x = 2
    v[1:-1, -1] = (vn[1:-1, -1] - un[1:-1, -1] * dt / dx *
                  (vn[1:-1, -1] - vn[1:-1, -2]) - 
                   vn[1:-1, -1] * dt / dy *
                  (vn[1:-1, -1] - vn[0:-2, -1]) -
                   dt / (2 * rho * dy) * 
                  (p[2:, -1] - p[0:-2, -1]) +
                   nu * (dt / dx**2 *
                  (vn[1:-1, 0] - 2 * vn[1:-1, -1] + vn[1:-1, -2]) +
                   dt / dy**2 *
                  (vn[2:, -1] - 2 * vn[1:-1, -1] + vn[0:-2, -1])))

    # Periodic BC v @ x = 0
    v[1:-1, 0] = (vn[1:-1, 0] - un[1:-1, 0] * dt / dx *
                 (vn[1:-1, 0] - vn[1:-1, -1]) -
                  vn[1:-1, 0] * dt / dy *
                 (vn[1:-1, 0] - vn[0:-2, 0]) -
                  dt / (2 * rho * dy) * 
                 (p[2:, 0] - p[0:-2, 0]) +
                  nu * (dt / dx**2 * 
                 (vn[1:-1, 1] - 2 * vn[1:-1, 0] + vn[1:-1, -1]) +
                  dt / dy**2 * 
                 (vn[2:, 0] - 2 * vn[1:-1, 0] + vn[0:-2, 0])))


    # Wall BC: u,v = 0 @ y = 0,2
    u[0, :] = 0
    u[-1, :] = 0
    v[0, :] = 0
    v[-1, :]=0
    
    udiff = (numpy.sum(u) - numpy.sum(un)) / numpy.sum(u)
    stepcount += 1

print(stepcount)

fig = pyplot.figure(figsize = (9,5), dpi=300)
pyplot.quiver(X[::3, ::3], Y[::3, ::3], u[::3, ::3], v[::3, ::3]);
pyplot.title('Professor')

fig = pyplot.figure(figsize = (9,5), dpi=300)
pyplot.quiver(X, Y, u, v);
</code></pre>

<pre><code>499
</code></pre>

<p><img src="../CFDPython_files/2DChannelInitProf.svg" alt="svg" /></p>

<p><img src="../CFDPython_files/2DChannelProf.svg" alt="svg" /></p>

<h4 id="student-13">Student</h4>

<p>Most of the cavity flow code can be reused here, with some changes for the boundary conditions and the source term.</p>

<pre><code class="language-python">def pressureSource(b, rho, u, v, dx, dy, dt):
    
    b[1:-1, 1:-1] = (rho*(1/(2.0*dt)*((u[2:, 1:-1] - u[:-2, 1:-1])/dx 
                    + (v[1:-1, 2:] - v[1:-1, :-2])/dy)
                    - ((u[2:, 1:-1] - u[:-2, 1:-1])/(2.0*dx))**2
                    - (u[1:-1, 2:] - u[1:-1, :-2])*(v[2:, 1:-1] - v[:-2, 1:-1])/(2.0*dx*dy)
                    - ((v[1:-1, 2:] - v[1:-1, :-2])/(2.0*dy))**2))
    
    # B/C at x = 2
    b[-1, 1:-1] = (rho*(1/(2.0*dt)*((u[0, 1:-1] - u[-2, 1:-1])/dx + (v[-1, 2:] - v[-1, :-2])/dy) 
                 - ((u[0, 1:-1] - u[-2, 1:-1])/(2.0*dx))**2
                 - (u[-1, 2:] - u[-1, :-2])*(v[0, 1:-1] - v[-2, 1:-1])/(2.0*dx*dy) 
                 - ((v[-1, 2:] - v[-1, :-2])/(2.0*dy))**2))
    # B/C at x = 0 
    b[0, 1:-1] = (rho*(1/(2.0*dt)*((u[1, 1:-1] - u[-1, 1:-1])/dx + (v[0, 2:] - v[0, :-2])/dy)
                - ((u[1, 1:-1] - u[-1, 1:-1])/(2.0*dx))**2
                - (u[0, 2:] - u[0, :-2])*(v[1, 1:-1] - v[-1, 1:-1])/(2.0*dx*dy)
                - ((v[0, 2:] - v[0, :-2])/(2.0*dy))**2))
    
    return b
                  
def pressurePoisson(p, b, dx, dy, sub_iterations=50):
    pn = p.copy()
    for n in range(sub_iterations):
        pn = p.copy()
        p[1:-1, 1:-1] = ((pn[2:, 1:-1] + pn[:-2, 1:-1])*dy**2
                        + (pn[1:-1, 2:] + pn[1:-1, :-2])*dx**2
                        - dx**2*dy**2*b[1:-1, 1:-1])/(2.0*(dx**2 + dy**2)) 
        # B/C at x = 2
        p[-1, 1:-1] = ((pn[0, 1:-1] + pn[-2, 1:-1])*dy**2
                     + (pn[-1, 2:] + pn[-1, :-2])*dx**2
                     - dx**2*dy**2*b[-1, 1:-1])/(2.0*(dx**2 + dy**2))
        # B/C at x = 0
        p[0, 1:-1] = ((pn[1, 1:-1] + pn[-1, 1:-1])*dy**2
                    + (pn[0, 2:] + pn[0, :-2])*dx**2
                    - dx**2*dy**2*b[0, 1:-1])/(2.0*(dx**2 + dy**2)) 
        
    p[:, -1] = p[:, -2]
    p[:, 0] = p[:, 1]
    
    return p
                
def channelFlow2D(bounds, mesh_size_x, mesh_size_y, timesteps, dt, u_init, v_init, p_init, F, rho, nu, sub_iterations=50, tolerance=1e-3):
    dx = abs(bounds[0][1] - bounds[0][0])/mesh_size_x 
    dy = abs(bounds[1][1] - bounds[1][0])/mesh_size_y
    u = numpy.zeros((timesteps, mesh_size_x, mesh_size_y))
    v = numpy.zeros((timesteps, mesh_size_x, mesh_size_y))
    p = numpy.zeros((timesteps, mesh_size_x, mesh_size_y))
    b = numpy.zeros((mesh_size_x, mesh_size_y))
    
    u[0, :, :] = u_init
    v[0, :, :] = v_init
    p[0, :, :] = p_init
    
    l_x = dt/dx
    l_y = dt/dy
    n_x = nu*dt/dx**2
    n_y = nu*dt/dy**2
    for n in range(1,timesteps):
#     rel = 1
#     n = 0
#     while rel &gt; tolerance:
    
        b = pressureSource(b, rho, u[n-1], v[n-1], dx, dy, dt)
        p[n] = pressurePoisson(p[n-1], b, dx, dy, sub_iterations)
        
        u[n, 1:-1, 1:-1] = (u[n-1, 1:-1, 1:-1]*(1 - l_x*(u[n-1, 1:-1, 1:-1] - u[n-1, :-2, 1:-1]))
                          - v[n-1, 1:-1, 1:-1]*l_y*(u[n-1, 1:-1, 1:-1] - u[n-1, 1:-1, :-2])
                          - l_x/(2.0*rho)*(p[n, 2:, 1:-1] - p[n, :-2, 1:-1])
                          + n_x*(u[n-1, 2:, 1:-1] - 2.0*u[n-1, 1:-1, 1:-1] + u[n-1, :-2, 1:-1])
                          + n_y*(u[n-1, 1:-1, 2:] - 2.0*u[n-1, 1:-1, 1:-1] + u[n-1, 1:-1, :-2]) + F*dt)
        
        v[n, 1:-1, 1:-1] = (v[n-1, 1:-1, 1:-1]*(1 - l_y*(v[n-1, 1:-1, 1:-1] - v[n-1, 1:-1, :-2]))
                          - u[n-1, 1:-1, 1:-1]*l_x*(v[n-1, 1:-1, 1:-1] - v[n-1, :-2, 1:-1])
                          - l_x/(2.0*rho)*(p[n, 1:-1, 2:] - p[n, 1:-1, :-2])
                          + n_x*(v[n-1, 2:, 1:-1] - 2.0*v[n-1, 1:-1, 1:-1] + v[n-1, :-2, 1:-1])
                          + n_y*(v[n-1, 1:-1, 2:] - 2.0*v[n-1, 1:-1, 1:-1] + v[n-1, 1:-1, :-2]))
        # B/C at x = 2
        u[n, -1, 1:-1] = (u[n-1, -1, 1:-1]*(1 - l_x*(u[n-1, -1, 1:-1] - u[n-1, -2, 1:-1]))
                        - v[n-1, -1, 1:-1]*l_y*(u[n-1, -1, 1:-1] - u[n-1, -1, :-2])
                        - l_x/(2.0*rho)*(p[n, 0, 1:-1] - p[n, -2, 1:-1])
                        + n_x*(u[n-1, 0, 1:-1] - 2.0*u[n-1, -1, 1:-1] + u[n-1, -2, 1:-1])
                        + n_y*(u[n-1, -1, 2:] - 2.0*u[n-1, -1, 1:-1] + u[n-1, -1, :-2]) + F*dt)
        
        # B/C at x = 0
        u[n, 0, 1:-1] = (u[n-1, 0, 1:-1]*(1 - l_x*(u[n-1, 0, 1:-1] - u[n-1, -1, 1:-1]))
                       - v[n-1, 0, 1:-1]*l_y*(u[n-1, 0, 1:-1] - u[n-1, 0, :-2])
                       - l_x/(2.0*rho)*(p[n, 1, 1:-1] - p[n, -1, 1:-1])
                       + n_x*(u[n-1, 1, 1:-1] - 2.0*u[n-1, 0, 1:-1] + u[n-1, -1, 1:-1])
                       + n_y*(u[n-1, 0, 2:] - 2.0*u[n-1, 0, 1:-1] + u[n-1, 0, :-2]) + F*dt)
        # B/C at x = 2
        v[n, -1, 1:-1] = (v[n-1, -1, 1:-1]*(1 - l_y*(v[n-1, -1, 1:-1] - v[n-1, -1, :-2]))
                        - u[n-1, -1, 1:-1]*l_x*(v[n-1, -1, 1:-1] - v[n-1, -2, 1:-1])
                        - l_y/(2.0*rho)*(p[n, -1, 2:] - p[n, -1, :-2])
                        + n_x*(v[n-1, 0, 1:-1] - 2.0*v[n-1, -1, 1:-1] + v[n-1, -2, 1:-1])
                        + n_y*(v[n-1, -1, 2:] - 2.0*v[n-1, -1, 1:-1] + v[n-1, -1, :-2]))
        # B/C at x = 0
        v[n, 0, 1:-1] = (v[n-1, 0, 1:-1]*(1 - l_y*(v[n-1, 0, 1:-1] - v[n-1, 0, :-2]))
                        - u[n-1, 0, 1:-1]*l_x*(v[n-1, 0, 1:-1] - v[n-1, -1, 1:-1])
                        - l_y/(2.0*rho)*(p[n, 0, 2:] - p[n, 0, :-2])
                        - n_x*(v[n-1, 1, 1:-1] - 2.0*v[n-1, 0, 1:-1] + v[n-1, -1, 1:-1])
                        + n_y*(v[n-1, 0, 2:] - 2.0*v[n-1, 0, 1:-1] + v[n-1, 0, :-2]))

#         rel = (numpy.sum(u[n]) - numpy.sum(u[n-1])) / numpy.sum(u[n])
#         n += 1
        
    return u, v, p

mesh_size_x = 41
mesh_size_y = 47
rho = 1
nu = .1
F = 1
timesteps = 1000
dt = .005
sub_iterations = 50
x_domain = (0,2)
y_domain = (0,2)
x = numpy.linspace(x_domain[0], x_domain[1], mesh_size_x)
y = numpy.linspace(y_domain[0], y_domain[1], mesh_size_y)
X, Y = numpy.meshgrid(x, y)
u_i = numpy.zeros((mesh_size_x, mesh_size_y))
v_i = numpy.zeros((mesh_size_x, mesh_size_y))
p_i = numpy.zeros((mesh_size_x, mesh_size_y))
u, v, p = channelFlow2D([x_domain, y_domain], mesh_size_x, mesh_size_y, timesteps, dt, u_i, v_i, p_i, F, rho, nu, sub_iterations)

fig = pyplot.figure(figsize=(9,5), dpi=300)
pyplot.quiver(X[::2, ::2], Y[::2, ::2], numpy.transpose(u[-1, ::2, ::2]), numpy.transpose(v[-1, ::2, ::2]))
pyplot.title('Student')
</code></pre>

<p><img src="../CFDPython_files/2DChannelStud.svg" alt="svg" /></p>

<p>I&rsquo;m cured!</p>

<p><code>*hic*</code> I&rsquo;m singin&rsquo; in the rain. <code>*hic*</code><br />
<code>*hic*</code> Just singin&rsquo; in the rain. <code>*hic*</code><br />
<code>*hic*</code> What a glorious feeling. <code>*hic*</code><br />
<code>*hic*</code> I&rsquo;m happy again. <code>*hic*</code><br />
<code>*hic*</code> I&rsquo;m laughin&rsquo; at clouds. <code>*hic*</code><br />
<code>*hic*</code> So dark up above. <code>*hic*</code></p>

	</article>
</main>

<div id="bottom-nav" class="text-center center-block">
	<a href=" https://godot-bloggy.xyz/" class="btn btn-default"><i class="fa fa-home"></i> Home</a>
</div>


  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "godotmisogi" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


						</div>
					</div>
				</div>
			</div>
		</div>
  </div>
   <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.2/js/bootstrap.min.js"></script>
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/topojson/1.6.9/topojson.min.js"></script>
  
  <script src="https://godot-bloggy.xyz/js/App.js"></script>
  
  
  <script src="https://godot-bloggy.xyz/js/prism.js"></script>
  
  </body>
</html>
